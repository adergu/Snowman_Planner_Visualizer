<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowman Planner Visualizer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS for Excel export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Import map for Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
            }
        }
    </script>
    <style>
        /* Keyframe animations for fade-in and pulse effects */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        /* Styling for control panel buttons */
        .control-btn {
            transition: all 0.3s ease;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 12px;
        }
        .control-btn:hover { transform: scale(1.1); }
        .control-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .control-btn svg { width: 20px; height: 20px; fill: currentColor; }
        /* Styling for the main control panel */
        #controlPanel {
            position: absolute;
            top: 50px;
            left: 10px;
            background: rgba(75, 85, 99, 0.8);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: move;
            user-select: none;
            resize: both;
            min-width: 200px;
            min-height: 150px;
            max-width: 400px;
            max-height: 600px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        #controlPanel.minimized { height: 40px; min-height: 40px; }
        #resizeHandle { width: 15px; height: 15px; position: absolute; bottom: 0; right: 0; cursor: se-resize; background: #4B5563; }
        #minimizeBtn { position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; background: #EF4444; border-radius: 50%; text-align: center; line-height: 20px; color: white; cursor: pointer; }
        #minimizeBtn:hover { background: #DC2626; }
        #canvas { position: absolute; top: 40px; right: 0; width: 65%; height: calc(100% - 40px - 30px); }
        #timelineCanvas { display: none; }
        header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to right, #1e3a8a, #4b5cb6);
            color: white;
            padding: 5px 20px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 18px;
            font-weight: bold;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            height: 40px;
            line-height: 30px;
        }
        footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to right, #1e3a8a, #4b5cb6);
            color: white;
            padding: 5px 20px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            z-index: 20;
            height: 30px;
            line-height: 20px;
        }
        #errorPopup, #helpPopup, #metricsPopup, #aboutPopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(75, 85, 99, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            max-width: 400px;
            text-align: left;
        }
        #errorPopup { background: rgba(255, 75, 75, 0.9); }
        #errorPopup button, #helpPopup button, #metricsPopup button, #aboutPopup button {
            background: #2563EB;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 10px;
        }
        #errorPopup button:hover, #helpPopup button:hover, #metricsPopup button:hover, #aboutPopup button:hover { background: #1D4ED8; }
        #menuBtn { position: absolute; top: 5px; right: 30px; width: 20px; height: 20px; background: #2563EB; border-radius: 50%; text-align: center; line-height: 20px; color: white; cursor: pointer; }
        #menuBtn:hover { background: #1D4ED8; }
        #menuDropdown {
            position: absolute;
            top: 30px;
            right: 10px;
            background: rgba(75, 85, 99, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 100;
        }
        #menuDropdown button { display: block; width: 100%; padding: 10px; color: white; background: none; border: none; text-align: left; cursor: pointer; }
        #menuDropdown button:hover { background: rgba(255, 255, 255, 0.1); }
    </style>
</head>
<body class="m-0 bg-gradient-to-b from-blue-900 to-gray-900">
    <div id="app" class="relative w-full h-screen">
        <header>
            Snowman Planner Visualizer - Intelligent System Planning
            <div id="menuBtn">☰</div>
            <div id="menuDropdown">
                <button id="helpBtn">Help</button>
                <button id="metricsBtn">Metrics</button>
                <button id="aboutBtn">About</button>
            </div>
        </header>
        <canvas id="canvas"></canvas>
        <div id="controlPanel" class="animate-[fadeIn_0.5s]">
            <div id="minimizeBtn">-</div>
            <label class="text-white text-lg font-bold mb-2">Choose Files</label>
            <div class="flex flex-col gap-2">
                <label class="text-gray-300 text-sm">Problem File (.pddl):</label>
                <input id="problemFile" type="file" accept=".pddl" class="mb-3 text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                <label class="text-gray-300 text-sm">Plan File (.txt/.plan):</label>
                <input id="planFile" type="file" accept=".txt,.plan" class="mb-3 text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-blue-600 file:text-white hover:file:bg-blue-700">
            </div>
            <div class="flex flex-wrap justify-between gap-2">
                <button id="stepBackward" class="control-btn bg-blue-500 hover:bg-blue-600 text-white rounded-full shadow-md" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z"/></svg>
                    <span>Prev</span>
                </button>
                <button id="playPause" class="control-btn bg-green-500 hover:bg-green-600 text-white rounded-full shadow-md" disabled>
                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                    <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    <span id="playPauseText">Play</span>
                </button>
                <button id="stepForward" class="control-btn bg-blue-500 hover:bg-blue-600 text-white rounded-full shadow-md" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M8.59 16.59L13.17 12l-4.58-4.59L10 6l6 6-6 6z"/></svg>
                    <span>Next</span>
                </button>
                <button id="reset" class="control-btn bg-red-500 hover:bg-red-600 text-white rounded-full shadow-md" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V2L7 7l5 5V9c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                    <span>Reset</span>
                </button>
            </div>
            <div class="flex items-center gap-2">
                <label class="text-gray-300 text-sm">Speed:</label>
                <input id="speed" type="range" min="0.5" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg cursor-pointer">
            </div>
            <div class="flex items-center gap-2">
                <label class="text-gray-300 text-sm">Snow Speed:</label>
                <input id="snowSpeed" type="range" min="0.1" max="0.5" step="0.1" value="0.2" class="w-full h-2 bg-gray-700 rounded-lg cursor-pointer">
            </div>
            <div class="flex items-center gap-2">
                <label class="text-gray-300 text-sm">Step:</label>
                <input id="step" type="range" min="0" max="0" step="1" value="0" class="w-full h-2 bg-gray-700 rounded-lg cursor-pointer" disabled>
            </div>
            <div id="resizeHandle"></div>
        </div>
        <div id="errorPopup">
            <p id="errorMessage"></p>
            <button id="errorClose">Close</button>
        </div>
        <div id="helpPopup">
            <p id="helpMessage">
                <strong>How to Use the Snowman Planner Visualizer:</strong><br>
                1. Select a problem file (.pddl) using the "Problem File" input.<br>
                2. Select a plan file (.txt or .plan) using the "Plan File" input.<br>
                3. Use the "Play/Pause" button to start or pause the animation.<br>
                4. Use "Next" and "Prev" to step through the plan manually.<br>
                5. Adjust the "Speed" slider to control animation speed.<br>
                6. Adjust the "Snow Speed" slider to control snowflake fall speed.<br>
                7. Use the "Step" slider to jump to a specific step.<br>
                8. Click "Reset" to clear the scene and start over.<br>
                9. Drag the control panel to reposition it, resize it using the bottom-right corner, or minimize it using the red button.
            </p>
            <button id="helpClose">Close</button>
        </div>
        <div id="metricsPopup">
            <p id="metricsMessage"></p>
            <button id="exportMetrics" class="bg-green-500 hover:bg-green-600">Export to Excel</button>
            <button id="metricsClose">Close</button>
        </div>
        <div id="aboutPopup">
            <p id="aboutMessage">
                <strong>About Snowman Planner Visualizer:</strong><br>
                This project visualizes a PDDL-based snowman-building plan, developed by MSc AI and CS students at Unical for the 2025/2026 academic year. It uses Three.js for 3D rendering and Tailwind CSS for styling, allowing users to animate and interact with planning solutions in a 5x5 grid environment.
            </p>
            <button id="aboutClose">Close</button>
        </div>
        <footer>© Unical 2025/2026 MSc AI and CS student's</footer>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const RADIUS = { 0: 0.15, 1: 0.25, 2: 0.35 };
        const SUBSTEPS = 10;
        const GOAL_POS = '2,0';
        const SNOW_COLOR = 0xE0FFFF;
        const REGULAR_GRID_COLOR = 0x90EE90;
        const UNTOUCHED_GRID_COLOR = 0x556B2F;
        const SPECIAL_GRID_POSITIONS = ['1,1', '1,3', '3,1', '3,3'];
        const CHARACTER_DEFAULT_COLOR = 0x8B4513;
        const FALLBACK_CHARACTER_COLOR = 0xFFFF00;

        let defaultProblemData = {
            grid_size: 5,
            snow: Object.fromEntries(Array(5).fill().flatMap((_, x) => Array(5).fill().map((_, y) => [[x, y].join(','), x === 0 || x === 4]))),
            balls: {},
            ball_size: {},
            character: '2,1'
        };
        let planData = { problem: defaultProblemData, frames: [], isNumeric: false };
        let currentFrame = 0;
        let isPlaying = false;
        let speed = 1;
        let snowSpeed = 0.2;
        let scene, camera, renderer, controls, grid = {}, balls = {}, character, mixer, particles, particleVelocities = [], snowParticles = [], snowParticleVelocities = [], pathLine, spotlight;
        let forbiddenIcons = {};
        const clock = new THREE.Clock();
        let currentTime = 0;
        let startTime = null;
        let problemFile = null;
        let planFile = null;

        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const playPauseText = document.getElementById('playPauseText');

        function showPopup(popupId, messageId, message) {
            document.querySelectorAll('#errorPopup, #helpPopup, #metricsPopup, #aboutPopup').forEach(p => p.style.display = 'none');
            const popup = document.getElementById(popupId);
            const messageEl = document.getElementById(messageId);
            messageEl.innerHTML = message;
            popup.style.display = 'block';
        }

        function hidePopup(popupId) {
            document.getElementById(popupId).style.display = 'none';
        }

        function parseLoc(loc) {
            try {
                const parts = loc.split('_');
                if (parts.length < 3) throw new Error(`Invalid location format: ${loc}`);
                return [parseInt(parts[1]) - 1, parseInt(parts[2]) - 1];
            } catch (e) {
                console.error(`Error parsing location '${loc}': ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error parsing location '${loc}': ${e.message}`);
                throw e;
            }
        }

        function parseProblem(content) {
            try {
                if (!content.trim()) throw new Error("Problem file is empty");
                let snow = {}, balls = {}, ballSize = {}, character = null;
                let gridPositions = new Set();
                let domain = 'unknown';
                const domainMatch = content.match(/:domain (\S+)/);
                if (domainMatch) domain = domainMatch[1];
                const locTypeRegex = /\(= \(location_type (\S+)\) (\d+)\)/g;
                let match;
                while ((match = locTypeRegex.exec(content)) !== null) {
                    const loc = match[1];
                    const t = match[2];
                    const coord = parseLoc(loc);
                    snow[coord.join(',')] = (t === '1');
                    gridPositions.add(coord.join(','));
                }
                const snowRegex = /\(snow (\S+)\)/g;
                while ((match = snowRegex.exec(content)) !== null) {
                    const loc = match[1];
                    const coord = parseLoc(loc);
                    snow[coord.join(',')] = true;
                    gridPositions.add(coord.join(','));
                }
                const ballAtRegex = /\(ball_at (\S+) (\S+)\)/g;
                while ((match = ballAtRegex.exec(content)) !== null) {
                    const [_, ball, loc] = match;
                    gridPositions.add(parseLoc(loc).join(','));
                    balls[ball] = parseLoc(loc);
                }
                const ballSizeNumRegex = /\(= \(ball_size (\S+)\) (\d+)\)/g;
                while ((match = ballSizeNumRegex.exec(content)) !== null) {
                    const [_, ball, size] = match;
                    const sizeInt = parseInt(size);
                    if (![0, 1, 2].includes(sizeInt)) throw new Error(`Invalid ball size ${size} for ball ${ball}. Must be 0, 1, or 2.`);
                    ballSize[ball] = sizeInt;
                }
                const ballSizeClassicRegex = /\(ball_size_(small|medium|large) (\S+)\)/g;
                while ((match = ballSizeClassicRegex.exec(content)) !== null) {
                    const [_, sizeStr, ball] = match;
                    const sizeMap = { 'small': 0, 'medium': 1, 'large': 2 };
                    ballSize[ball] = sizeMap[sizeStr.toLowerCase()];
                }
                const charMatch = content.match(/\(character_at (\S+)\)/);
                if (charMatch) {
                    character = parseLoc(charMatch[1]);
                    gridPositions.add(character.join(','));
                }
                if (Object.keys(balls).length === 0) console.warn("No balls found in problem file.");
                if (!character) throw new Error("No character position found in problem file.");
                for (let ball in balls) {
                    if (!(ball in ballSize)) ballSize[ball] = 0;
                }
                let gridSize = 5;
                if (gridPositions.size > 0) {
                    const coords = Array.from(gridPositions).map(c => c.split(',').map(Number));
                    const maxR = Math.max(...coords.map(c => c[0]));
                    const maxC = Math.max(...coords.map(c => c[1]));
                    gridSize = Math.max(maxR, maxC) + 1;
                }
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (!(r + ',' + c in snow)) snow[r + ',' + c] = false;
                    }
                }
                return { snow, balls, ball_size: ballSize, character: character.join(','), grid_size: gridSize, domain };
            } catch (e) {
                console.error(`Error parsing problem file: ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error parsing problem file: ${e.message}`);
                throw e;
            }
        }

        function parsePlan(content) {
            try {
                if (!content.trim()) throw new Error("Plan file is empty");
                const steps = [];
                const lines = content.trim().split('\n');
                for (let line of lines) {
                    line = line.trim();
                    if (!line || line.startsWith(';')) continue;
                    let cleanedLine = line.replace(/^\d+\.\d+:\s*/, '').replace(/^\d+[.:]?\s*/, '');
                    if (cleanedLine.startsWith('(') && cleanedLine.endsWith(')')) {
                        cleanedLine = cleanedLine.slice(1, -1).trim();
                    }
                    if (cleanedLine && ['move', 'move_to', 'move_ball', 'push', 'roll', 'roll_ball', 'goal', 'move_character'].some(k => cleanedLine.toLowerCase().includes(k))) {
                        steps.push(cleanedLine);
                    }
                }
                if (steps.length === 0) throw new Error("No valid actions found in plan file.");
                return steps;
            } catch (e) {
                console.error(`Error parsing plan file: ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error parsing plan file: ${e.message}`);
                throw e;
            }
        }

        function buildFrames(prob, plan) {
            try {
                const frames = [];
                const state = {
                    snow: { ...prob.snow },
                    balls: Object.fromEntries(Object.entries(prob.balls).map(([k, v]) => [k, v.join(',')])),
                    ball_size: { ...prob.ball_size },
                    character: prob.character,
                    grid_size: prob.grid_size,
                    isNumeric: prob.domain.includes('snowman_numeric')
                };
                frames.push({
                    type: 'initial',
                    balls: { ...state.balls },
                    ball_size: { ...state.ball_size },
                    snow: { ...state.snow },
                    character: state.character,
                    grid_size: state.grid_size,
                    time: 0,
                    alpha: 0
                });
                let step_count = 0;
                for (let action of plan) {
                    const parts = action.split(/\s+/);
                    let currentCharacterPos = state.character;
                    let currentBallPos = { ...state.balls };
                    try {
                        if (['move_character', 'move', 'move_to'].includes(parts[0])) {
                            if (parts.length < 3) throw new Error(`Invalid move action: ${action}`);
                            const start = parseLoc(parts[1]);
                            const end = parseLoc(parts[2]);
                            const direction = parts.length > 3 ? parts[3] : null;
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'move',
                                    start: start.join(','),
                                    end: end.join(','),
                                    alpha,
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: currentCharacterPos,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    direction
                                });
                            }
                            state.character = end.join(',');
                        } else if (['move_ball', 'push', 'roll', 'roll_ball'].includes(parts[0])) {
                            if (parts.length < 5) throw new Error(`Invalid move_ball action: ${action}`);
                            const [_, ball, fromCell, midCell, toCell] = parts;
                            const start = parseLoc(fromCell);
                            const end = parseLoc(toCell);
                            const direction = parts.length > 5 ? parts[5] : null;
                            const charStart = state.character;
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'move_to_ball',
                                    start: charStart,
                                    end: start.join(','),
                                    alpha,
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    direction
                                });
                            }
                            state.character = start.join(',');
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'move_ball',
                                    ball,
                                    start: start.join(','),
                                    end: end.join(','),
                                    alpha,
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    direction
                                });
                            }
                            state.balls[ball] = end.join(',');
                            if (state.snow[end.join(',')] && (state.isNumeric || !state.isNumeric)) {
                                state.ball_size[ball] = Math.min(state.ball_size[ball] + 1, 2);
                                state.snow[end.join(',')] = false;
                            }
                        } else if (parts[0] === 'goal') {
                            const ballsAtGoal = Object.entries(state.balls).filter(([_, pos]) => pos === GOAL_POS).map(([b]) => b);
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'goal',
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    alpha
                                });
                            }
                        } else {
                            console.warn(`Unknown action '${action}' on step ${step_count + 1}`);
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'static',
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    alpha
                                });
                            }
                        }
                        step_count++;
                    } catch (e) {
                        console.error(`Error processing action '${action}' on step ${step_count + 1}: ${e}`);
                        showPopup('errorPopup', 'errorMessage', `Error processing action '${action}' on step ${step_count + 1}: ${e.message}`);
                        for (let t = 0; t < SUBSTEPS; t++) {
                            const alpha = t / (SUBSTEPS - 1);
                            frames.push({
                                type: 'error',
                                balls: { ...state.balls },
                                ball_size: { ...state.ball_size },
                                snow: { ...state.snow },
                                character: state.character,
                                grid_size: state.grid_size,
                                time: step_count + alpha,
                                alpha
                            });
                        }
                        step_count++;
                    }
                }
                return frames;
            } catch (e) {
                console.error(`Error building frames: ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error building frames: ${e.message}`);
                throw e;
            }
        }

        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
                reader.readAsText(file);
            });
        }

        async function selectFiles(e) {
            const problemInput = document.getElementById('problemFile');
            const planInput = document.getElementById('planFile');
            const changedInput = e.target.id;
            console.log(`File input changed: ${changedInput}`);
            if (changedInput === 'problemFile' && problemInput.files[0]) {
                if (!problemInput.files[0].name.endsWith('.pddl')) {
                    console.error('Invalid problem file selected');
                    showPopup('errorPopup', 'errorMessage', 'Please select a valid problem file (.pddl).');
                    problemInput.value = '';
                    problemFile = null;
                    return;
                }
                problemFile = problemInput.files[0];
                console.log(`Problem file selected: ${problemFile.name}`);
            } else if (changedInput === 'planFile' && planInput.files[0]) {
                if (!planInput.files[0].name.endsWith('.txt') && !planInput.files[0].name.endsWith('.plan')) {
                    console.error('Invalid plan file selected');
                    showPopup('errorPopup', 'errorMessage', 'Please select a valid plan file (.txt or .plan).');
                    planInput.value = '';
                    planFile = null;
                    return;
                }
                planFile = planInput.files[0];
                console.log(`Plan file selected: ${planFile.name}`);
            }
            if (problemFile && planFile) {
                console.log('Both files selected, attempting to load');
                try {
                    resetScene(false);
                    const [problemContent, planContent] = await Promise.all([
                        readFile(problemFile),
                        readFile(planFile)
                    ]);
                    await loadFiles(problemContent, planContent, problemFile.name, planFile.name);
                    if (planData.frames.length > 0) {
                        updateFrame(planData.frames[0]);
                        renderer.render(scene, camera);
                    }
                } catch (err) {
                    console.error(`Error reading files: ${err.message}`);
                    showPopup('errorPopup', 'errorMessage', `Error reading files: ${err.message}`);
                    resetScene(false);
                }
            } else {
                console.log('Waiting for both files to be selected');
                ['playPause', 'stepForward', 'stepBackward', 'reset', 'step'].forEach(id => {
                    document.getElementById(id).disabled = true;
                });
            }
        }

        async function loadFiles(problemContent, planContent, problemFileName, planFileName) {
            try {
                console.log(`Loading files: ${problemFileName}, ${planFileName}`);
                startTime = performance.now();
                const problem = parseProblem(problemContent);
                const plan = parsePlan(planContent);
                planData = {
                    problem,
                    frames: buildFrames(problem, plan),
                    isNumeric: problem.domain.includes('snowman_numeric')
                };
                currentFrame = 0;
                isPlaying = false;
                currentTime = 0;
                document.getElementById('step').max = Math.max(0, Math.floor(planData.frames.length / SUBSTEPS) - 1);
                document.getElementById('step').value = 0;
                document.getElementById('step').disabled = false;
                ['playPause', 'stepForward', 'stepBackward', 'reset'].forEach(id => document.getElementById(id).disabled = false);
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                playPauseText.textContent = 'Play';
                console.log('Clearing existing dynamic scene objects before re-initialization.');
                clearDynamicSceneObjects();
                console.log('Initializing dynamic scene objects with loaded data.');
                await initDynamicSceneObjects(planData.problem);
                console.log(`Dynamic scene initialized, frames: ${planData.frames.length}`);
                if (planData.frames.length > 0) {
                    console.log('Rendering first frame');
                    updateFrame(planData.frames[0]);
                    renderer.render(scene, camera);
                }
            } catch (err) {
                console.error('Error loading plan:', err);
                showPopup('errorPopup', 'errorMessage', `Error loading plan: ${err.message}`);
                resetScene(false);
            }
        }

        function createForbiddenIcon() {
            const barrierGroup = new THREE.Group();
            const barrierMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.5, metalness: 0.1 });
            const baseGeometry = new THREE.BoxGeometry(0.8, 0.05, 0.2);
            const baseMesh = new THREE.Mesh(baseGeometry, barrierMaterial);
            baseMesh.position.y = 0.025;
            baseMesh.castShadow = true;
            baseMesh.receiveShadow = true;
            barrierGroup.add(baseMesh);
            const postGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.05);
            const post1 = new THREE.Mesh(postGeometry, barrierMaterial);
            post1.position.set(-0.3, 0.15 + 0.025, 0);
            post1.castShadow = true;
            post1.receiveShadow = true;
            barrierGroup.add(post1);
            const post2 = new THREE.Mesh(postGeometry, barrierMaterial);
            post2.position.set(0.3, 0.15 + 0.025, 0);
            post2.castShadow = true;
            post2.receiveShadow = true;
            barrierGroup.add(post2);
            return barrierGroup;
        }

        function clearDynamicSceneObjects() {
            console.log('Clearing dynamic scene objects...');
            const objectsToRemove = [];
            scene.traverse(object => {
                if (object.name && (
                    object.name.startsWith('ball_') ||
                    object.name === 'character'
                )) {
                    objectsToRemove.push(object);
                }
            });
            objectsToRemove.forEach(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => mat.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
                scene.remove(object);
            });
            balls = {};
            character = null;
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            if (spotlight) {
                spotlight.target.position.set(defaultProblemData.grid_size / 2, 0, defaultProblemData.grid_size / 2);
                spotlight.position.set(defaultProblemData.grid_size / 2, 3, defaultProblemData.grid_size / 2);
            }
            console.log('Dynamic scene objects cleared.');
        }

        async function initStaticEnvironment(problemDataForStatic) {
            console.log('Initializing static environment objects...');
            const staticObjectsToRemove = [];
            scene.traverse(object => {
                if (object.name && (
                    object.name.startsWith('grid_') ||
                    object.name === 'ground_plane' ||
                    object.name.startsWith('wall_') ||
                    object.name.startsWith('tree_') ||
                    object.name.startsWith('forbidden_icon_')
                )) {
                    staticObjectsToRemove.push(object);
                }
            });
            staticObjectsToRemove.forEach(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) object.material.forEach(m => m.dispose());
                    else object.material.dispose();
                }
                scene.remove(object);
            });
            grid = {};
            forbiddenIcons = {};
            const groundGeometry = new THREE.PlaneGeometry(problemDataForStatic.grid_size + 2, problemDataForStatic.grid_size + 2);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: SNOW_COLOR, roughness: 0.8, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(problemDataForStatic.grid_size / 2, -0.01, problemDataForStatic.grid_size / 2);
            ground.receiveShadow = true;
            ground.name = 'ground_plane';
            scene.add(ground);
            const [goalX, goalY] = GOAL_POS.split(',').map(Number);
            for (let x = 0; x < problemDataForStatic.grid_size; x++) {
                for (let y = 0; y < problemDataForStatic.grid_size; y++) {
                    const coord = `${x},${y}`;
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    let materialColor;
                    if (SPECIAL_GRID_POSITIONS.includes(coord)) {
                        materialColor = 0xFFFFFF;
                        const icon = createForbiddenIcon();
                        icon.position.set(x + 0.5, 0, y + 0.5);
                        icon.name = `forbidden_icon_${coord}`;
                        scene.add(icon);
                        forbiddenIcons[coord] = icon;
                    } else if (problemDataForStatic.snow[coord]) {
                        materialColor = SNOW_COLOR;
                    } else if (x === goalX && y === goalY) {
                        materialColor = REGULAR_GRID_COLOR;
                    } else {
                        materialColor = UNTOUCHED_GRID_COLOR;
                    }
                    const material = new THREE.MeshStandardMaterial({ color: materialColor, side: THREE.DoubleSide });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.rotation.x = -Math.PI / 2;
                    plane.position.set(x + 0.5, 0, y + 0.5);
                    plane.receiveShadow = true;
                    plane.name = `grid_${coord}`;
                    scene.add(plane);
                    grid[coord] = plane;
                }
            }
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.7, roughness: 0.3, metalness: 0.5 });
            const wallHeight = 0.5;
            const wallThickness = 0.2;
            const halfGridSize = problemDataForStatic.grid_size / 2;
            [
                { geometry: new THREE.BoxGeometry(problemDataForStatic.grid_size + wallThickness * 2, wallHeight, wallThickness), position: [halfGridSize, wallHeight / 2, -wallThickness / 2], name: 'wall_top' },
                { geometry: new THREE.BoxGeometry(problemDataForStatic.grid_size + wallThickness * 2, wallHeight, wallThickness), position: [halfGridSize, wallHeight / 2, problemDataForStatic.grid_size + wallThickness / 2], name: 'wall_bottom' },
                { geometry: new THREE.BoxGeometry(wallThickness, wallHeight, problemDataForStatic.grid_size + wallThickness * 2), position: [-wallThickness / 2, wallHeight / 2, halfGridSize], name: 'wall_left' },
                { geometry: new THREE.BoxGeometry(wallThickness, wallHeight, problemDataForStatic.grid_size + wallThickness * 2), position: [problemDataForStatic.grid_size + wallThickness / 2, wallHeight / 2, halfGridSize], name: 'wall_right' }
            ].forEach(({ geometry, position, name }) => {
                const wall = new THREE.Mesh(geometry, wallMaterial);
                wall.position.set(...position);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.name = name;
                scene.add(wall);
            });
            const treeGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 });
            const treePositions = [
                [-1, 0, -1], [problemDataForStatic.grid_size + 1, 0, -1],
                [-1, 0, problemDataForStatic.grid_size + 1], [problemDataForStatic.grid_size + 1, 0, problemDataForStatic.grid_size + 1],
                [halfGridSize, 0, -1], [halfGridSize, 0, problemDataForStatic.grid_size + 1],
                [-1, 0, halfGridSize], [problemDataForStatic.grid_size + 1, 0, halfGridSize]
            ];
            treePositions.forEach((pos, index) => {
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.set(pos[0], pos[1] + 0.4, pos[2]);
                tree.castShadow = true;
                tree.receiveShadow = true;
                tree.name = `tree_${index}`;
                scene.add(tree);
            });
        }

        async function initDynamicSceneObjects(problemData) {
            console.log('[initDynamicSceneObjects] Setting up dynamic scene objects with problem data:', problemData);
            const loader = new GLTFLoader();
            if (!character) {
                try {
                    const gltf = await new Promise((resolve, reject) => loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/Soldier.glb', resolve, undefined, reject));
                    character = gltf.scene;
                    character.scale.set(0.4, 0.4, 0.4);
                    character.castShadow = true;
                    character.receiveShadow = true;
                    character.name = 'character';
                    if (gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(character);
                        gltf.animations.forEach(clip => mixer.clipAction(clip).play());
                    }
                    character.traverse(obj => {
                        if (obj.isMesh && obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(mat => {
                                    if (mat.type === 'MeshStandardMaterial' || mat.type === 'MeshBasicMaterial') {
                                        mat.color.set(CHARACTER_DEFAULT_COLOR);
                                    }
                                });
                            } else {
                                if (obj.material.type === 'MeshStandardMaterial' || obj.material.type === 'MeshBasicMaterial') {
                                    obj.material.color.set(CHARACTER_DEFAULT_COLOR);
                                }
                            }
                        }
                    });
                } catch (e) {
                    console.warn('[initDynamicSceneObjects] Failed to load character model, using fallback (yellow box).', e);
                    character = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.3), new THREE.MeshStandardMaterial({ color: FALLBACK_CHARACTER_COLOR }));
                    character.position.y = 0.4;
                    character.castShadow = true;
                    character.name = 'character';
                }
                scene.add(character);
            }
            if (character) {
                character.visible = true;
            }
            const [cx, cy] = problemData.character.split(',').map(Number);
            character.position.set(cx + 0.5, 0, cy + 0.5);
            for (const ballName in balls) {
                scene.remove(balls[ballName]);
                if (balls[ballName].geometry) balls[ballName].geometry.dispose();
                if (balls[ballName].material) {
                    if (Array.isArray(balls[ballName].material)) balls[ballName].material.forEach(m => m.dispose());
                    else balls[ballName].material.dispose();
                }
                delete balls[ballName];
            }
            balls = {};
            for (let b in problemData.balls) {
                const geometry = new THREE.SphereGeometry(RADIUS[problemData.ball_size[b]], 32, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.2 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                const [x, y] = problemData.balls[b];
                sphere.position.set(x + 0.5, RADIUS[problemData.ball_size[b]], y + 0.5);
                sphere.name = `ball_${b}`;
                scene.add(sphere);
                balls[b] = sphere;
            }
            if (spotlight) { scene.remove(spotlight); scene.remove(spotlight.target); }
            spotlight = new THREE.SpotLight(0xffffff, 0, 5, Math.PI / 4, 0.5, 2);
            spotlight.position.set(cx + 0.5, 3, cy + 0.5);
            spotlight.castShadow = true;
            scene.add(spotlight);
            scene.add(spotlight.target);
        }

        async function initCoreThreeJs() {
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, 0.65 * window.innerWidth / window.innerHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
                renderer.setSize(window.innerWidth * 0.65, window.innerHeight - 70);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                scene.fog = new THREE.Fog(0x87CEEB, 3, 10);
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                const skyboxLoader = new THREE.CubeTextureLoader();
                skyboxLoader.load([
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_px.jpg',
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_nx.jpg',
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_py.jpg',
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_ny.jpg',
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_pz.jpg',
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_nz.jpg'
                ], texture => { scene.background = texture; }, undefined, () => { scene.background = new THREE.Color(0x87CEEB); });
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 2;
                controls.maxDistance = 10;
                camera.position.set(defaultProblemData.grid_size / 2, 3, defaultProblemData.grid_size);
                controls.target.set(defaultProblemData.grid_size / 2, 0, defaultProblemData.grid_size / 2);
                const snowParticleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                function dropSnowflake() {
                    const size = 0.009 + Math.random() * 0.012;
                    const geometry = new THREE.CircleGeometry(size, 32);
                    const mesh = new THREE.Mesh(geometry, snowParticleMaterial);
                    mesh.position.set(Math.random() * (defaultProblemData.grid_size + 2) - 1, Math.random() * 5 + 3, Math.random() * (defaultProblemData.grid_size + 2) - 1);
                    const velocity = new THREE.Vector3((Math.random() - 0.5) * 0.05 + 0.02 * Math.sin(clock.getElapsedTime()), -snowSpeed, (Math.random() - 0.5) * 0.05 + 0.02 * Math.cos(clock.getElapsedTime()));
                    snowParticles.push(mesh);
                    snowParticleVelocities.push(velocity);
                    scene.add(mesh);
                }
                setInterval(dropSnowflake, 300);
                const pathGeometry = new THREE.BufferGeometry();
                const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
                pathLine = new THREE.Line(pathGeometry, pathMaterial);
                scene.add(pathLine);
                animate();
            } catch (err) {
                console.error('Core Three.js Initialization error:', err);
                showPopup('errorPopup', 'errorMessage', `Core Three.js Initialization error: ${err.message}`);
            }
        }

        function updateFrame(f) {
            try {
                if (!f) return;
                const [goalX, goalY] = GOAL_POS.split(',').map(Number);
                for (let x = 0; x < f.grid_size; x++) {
                    for (let y = 0; y < f.grid_size; y++) {
                        const coord = `${x},${y}`;
                        if (grid[coord]) {
                            let newColor;
                            if (SPECIAL_GRID_POSITIONS.includes(coord)) {
                                newColor = 0xFFFFFF;
                            } else if (f.snow[coord]) {
                                newColor = SNOW_COLOR;
                            } else if (x === goalX && y === goalY) {
                                newColor = REGULAR_GRID_COLOR;
                            } else {
                                newColor = UNTOUCHED_GRID_COLOR;
                            }
                            grid[coord].material.color.set(newColor);
                            grid[coord].material.needsUpdate = true;
                        }
                    }
                }
                const ballsCurrentlyAtGoal = [];
                for (let b in f.balls) {
                    if (f.balls[b] === GOAL_POS) {
                        ballsCurrentlyAtGoal.push({ name: b, size: f.ball_size[b] });
                    }
                }
                ballsCurrentlyAtGoal.sort((a, b) => b.size - a.size);
                const [goalCellX, goalCellY] = GOAL_POS.split(',').map(Number);
                for (let b in f.balls) {
                    if (!balls[b]) {
                        console.warn(`[updateFrame] Creating ball ${b} dynamically. Should have been initialized.`);
                        const geometry = new THREE.SphereGeometry(RADIUS[f.ball_size[b]], 32, 32);
                        const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.2 });
                        balls[b] = new THREE.Mesh(geometry, material);
                        balls[b].castShadow = true;
                        balls[b].receiveShadow = true;
                        balls[b].name = `ball_${b}`;
                        scene.add(balls[b]);
                    } else {
                        if (balls[b].geometry.parameters.radius !== RADIUS[f.ball_size[b]]) {
                            balls[b].geometry.dispose();
                            balls[b].geometry = new THREE.SphereGeometry(RADIUS[f.ball_size[b]], 32, 32);
                        }
                    }
                    let posX, posY, posZ;
                    if (f.balls[b] === GOAL_POS) {
                        let currentHeight = 0;
                        for (let i = 0; i < ballsCurrentlyAtGoal.length; i++) {
                            const stackedBall = ballsCurrentlyAtGoal[i];
                            if (stackedBall.name === b) {
                                posY = currentHeight + RADIUS[stackedBall.size];
                                break;
                            }
                            currentHeight += (RADIUS[stackedBall.size] * 2);
                        }
                        posX = goalCellX + 0.5;
                        posZ = goalCellY + 0.5;
                        balls[b].visible = true;
                    } else if (['move_ball', 'push', 'roll', 'roll_ball'].includes(f.type) && f.ball === b) {
                        const [sx, sy] = f.start.split(',').map(Number);
                        const [ex, ey] = f.end.split(',').map(Number);
                        posX = sx + 0.5 + f.alpha * (ex - sx);
                        posZ = sy + 0.5 + f.alpha * (ey - sy);
                        posY = RADIUS[f.ball_size[b]];
                        balls[b].visible = true;
                    } else {
                        const [x, y] = f.balls[b].split(',').map(Number);
                        posX = x + 0.5;
                        posZ = y + 0.5;
                        posY = RADIUS[f.ball_size[b]];
                        balls[b].visible = true;
                    }
                    balls[b].position.set(posX, posY, posZ);
                }
                const ballsAtGoalFinalCheck = Object.entries(f.balls).filter(([_, pos]) => pos === GOAL_POS);
                const ballsAtGoalCount = ballsAtGoalFinalCheck.length;
                const sizesAtGoal = new Set(ballsAtGoalFinalCheck.map(([b]) => f.ball_size[b]));
                const isSnowmanFormed = (ballsAtGoalCount === 3 && sizesAtGoal.has(0) && sizesAtGoal.has(1) && sizesAtGoal.has(2));
                if (character) {
                    character.visible = !(isSnowmanFormed && f.character === GOAL_POS);
                }
                if (character && character.visible && f.character) {
                    let cx, cz, rotationY = 0;
                    if (f.type === 'move_to_ball') {
                        const [sx, sy] = f.start.split(',').map(Number);
                        const [ex, ey] = f.end.split(',').map(Number);
                        cx = sx + 0.5 + f.alpha * (ex - sx);
                        cz = sy + 0.5 + f.alpha * (ey - sy);
                        rotationY = f.direction === 'left' ? Math.PI : f.direction === 'right' ? 0 : f.direction === 'up' ? Math.PI / 2 : f.direction === 'down' ? -Math.PI / 2 : 0;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(cx, 0, cz);
                    } else if (['move_ball', 'push', 'roll', 'roll_ball'].includes(f.type)) {
                        const [bx, by] = f.start.split(',').map(Number);
                        const [ex, ey] = f.end.split(',').map(Number);
                        cx = bx + 0.5 + f.alpha * (ex - bx);
                        cz = by + 0.5 + f.alpha * (ey - by);
                        rotationY = f.direction === 'left' ? Math.PI : f.direction === 'right' ? 0 : f.direction === 'up' ? Math.PI / 2 : f.direction === 'down' ? -Math.PI / 2 : 0;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(balls[f.ball].position.x, balls[f.ball].position.y, balls[f.ball].position.z);
                    } else if (f.type === 'move') {
                        const [sx, sy] = f.start.split(',').map(Number);
                        const [ex, ey] = f.end.split(',').map(Number);
                        cx = sx + 0.5 + f.alpha * (ex - sx);
                        cz = sy + 0.5 + f.alpha * (ey - sy);
                        rotationY = f.direction === 'left' ? Math.PI : f.direction === 'right' ? 0 : f.direction === 'up' ? Math.PI / 2 : f.direction === 'down' ? -Math.PI / 2 : 0;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(cx, 0, cz);
                    } else {
                        const [x, y] = f.character.split(',').map(Number);
                        cx = x + 0.5;
                        cz = y + 0.5;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(cx, 0, cz);
                    }
                    character.position.set(cx, 0, cz);
                    character.rotation.y = rotationY;
                }
            } catch (err) {
                console.error('Error updating frame:', err);
                showPopup('errorPopup', 'errorMessage', `Error updating frame: ${err.message}`);
            }
        }

        function resetScene(clearFiles = true) {
            try {
                console.log('Resetting scene');
                planData = {
                    problem: { ...defaultProblemData },
                    frames: [],
                    isNumeric: false
                };
                currentFrame = 0;
                isPlaying = false;
                currentTime = 0;
                startTime = null;
                if (clearFiles) {
                    problemFile = null;
                    planFile = null;
                    document.getElementById('problemFile').value = '';
                    document.getElementById('planFile').value = '';
                }
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                playPauseText.textContent = 'Play';
                document.getElementById('step').value = 0;
                document.getElementById('step').max = 0;
                document.getElementById('step').disabled = true;
                ['playPause', 'stepForward', 'stepBackward', 'reset'].forEach(id => document.getElementById(id).disabled = true);
                clearDynamicSceneObjects();
                initStaticEnvironment(defaultProblemData);
                renderer.render(scene, camera);
            } catch (err) {
                console.error('Error resetting scene:', err);
                showPopup('errorPopup', 'errorMessage', `Error resetting scene: ${err.message}`);
            }
        }

        function getMetrics() {
            const totalSteps = Math.floor(planData.frames.length / SUBSTEPS);
            const planDuration = currentTime.toFixed(2);
            const ballsAtGoal = planData.frames.length > 0 ? Object.values(planData.frames[planData.frames.length - 1].balls).filter(pos => pos === GOAL_POS).length : 0;
            const sizesAtGoal = planData.frames.length > 0 ? Object.entries(planData.frames[planData.frames.length - 1].balls)
                .filter(([_, pos]) => pos === GOAL_POS)
                .map(([b]) => planData.frames[planData.frames.length - 1].ball_size[b]) : [];
            const isSnowmanFormed = (ballsAtGoal === 3 && new Set(sizesAtGoal).has(0) && new Set(sizesAtGoal).has(1) && new Set(sizesAtGoal).has(2));
            let characterMoves = 0;
            let ballPushes = 0;
            let snowCellsConsumed = 0;
            let forbiddenCellsEntered = 0;
            let totalDistance = 0;
            let usefulActions = 0;
            const initialSnowCells = Object.values(planData.problem.snow).filter(s => s).length;

            if (planData.frames.length > 0) {
                let lastCharacterPos = planData.frames[0].character;
                for (let i = 0; i < planData.frames.length; i += SUBSTEPS) {
                    const frame = planData.frames[i];
                    if (['move', 'move_to_ball'].includes(frame.type)) {
                        characterMoves++;
                        usefulActions++;
                        const [sx, sy] = frame.start.split(',').map(Number);
                        const [ex, ey] = frame.end.split(',').map(Number);
                        totalDistance += Math.abs(ex - sx) + Math.abs(ey - sy);
                        if (SPECIAL_GRID_POSITIONS.includes(frame.end) && frame.alpha === 0) {
                            forbiddenCellsEntered++;
                        }
                    } else if (['move_ball', 'push', 'roll', 'roll_ball'].includes(frame.type)) {
                        ballPushes++;
                        usefulActions++;
                        if (frame.snow[frame.end] && frame.alpha === 0) {
                            snowCellsConsumed++;
                        }
                        if (SPECIAL_GRID_POSITIONS.includes(frame.end) && frame.alpha === 1) {
                            forbiddenCellsEntered++;
                        }
                    }
                }
            }

            const avgBallSizeAtGoal = sizesAtGoal.length > 0 ? (sizesAtGoal.reduce((sum, size) => sum + size, 0) / sizesAtGoal.length).toFixed(2) : 0;
            const planEfficiency = totalSteps > 0 ? ((usefulActions / totalSteps) * 100).toFixed(2) : 0;
            const snowCoverage = initialSnowCells > 0 ? ((snowCellsConsumed / initialSnowCells) * 100).toFixed(2) : 0;

            return {
                display: `
                    <strong>Plan Metrics:</strong><br>
                    Total Steps: ${totalSteps}<br>
                    Plan Duration: ${planDuration} seconds<br>
                    Balls at Goal: ${ballsAtGoal}<br>
                    Goal Achieved: ${isSnowmanFormed ? 'Yes' : 'No'}<br>
                    Character Moves: ${characterMoves}<br>
                    Ball Pushes: ${ballPushes}<br>
                    Forbidden Cells Entered: ${forbiddenCellsEntered}<br>
                    Total Distance Traveled: ${totalDistance.toFixed(2)} units<br>
                    Plan Efficiency: ${planEfficiency}%
                `,
                data: [
                    ['Metric', 'Value'],
                    ['Total Steps', totalSteps],
                    ['Plan Duration (seconds)', planDuration],
                    ['Balls at Goal', ballsAtGoal],
                    ['Goal Achieved', isSnowmanFormed ? 'Yes' : 'No'],
                    ['Character Moves', characterMoves],
                    ['Ball Pushes', ballPushes],
                    ['Snow Cells Consumed', snowCellsConsumed],
                    ['Initial Snow Cells', initialSnowCells],
                    ['Snow Coverage (%)', snowCoverage],
                    ['Forbidden Cells Entered', forbiddenCellsEntered],
                    ['Average Ball Size at Goal', avgBallSizeAtGoal],
                    ['Total Distance Traveled (units)', totalDistance.toFixed(2)],
                    ['Plan Efficiency (%)', planEfficiency]
                ]
            };
        }

        function exportToExcel() {
            try {
                if (typeof XLSX === 'undefined') {
                    console.error('SheetJS library not loaded.');
                    showPopup('errorPopup', 'errorMessage', 'Export failed: SheetJS library not loaded.');
                    return;
                }
                const metrics = getMetrics();
                const ws = XLSX.utils.aoa_to_sheet(metrics.data);
                ws['!cols'] = [{ wch: 25 }, { wch: 15 }]; // Set column widths
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Plan Metrics');
                XLSX.writeFile(wb, 'Snowman_Planner_Metrics.xlsx');
            } catch (err) {
                console.error('Error exporting to Excel:', err);
                showPopup('errorPopup', 'errorMessage', `Error exporting to Excel: ${err.message}`);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            controls.update();
            if (isPlaying && planData.frames.length > 0 && currentFrame < planData.frames.length - 1) {
                updateFrame(planData.frames[Math.floor(currentFrame)]);
                currentFrame += speed;
                document.getElementById('step').value = Math.floor(currentFrame / SUBSTEPS);
                currentTime = startTime ? (performance.now() - startTime) / 1000 : 0;
                if (currentFrame >= planData.frames.length - 1) {
                    isPlaying = false;
                    playIcon.style.display = 'block';
                    pauseIcon.style.display = 'none';
                    playPauseText.textContent = 'Play';
                }
            }
            snowParticles.forEach((mesh, i) => {
                const velocity = snowParticleVelocities[i];
                mesh.position.x += velocity.x * delta;
                mesh.position.y += velocity.y * delta * snowSpeed;
                mesh.position.z += velocity.z * delta;
                if (mesh.position.y < 0) {
                    scene.remove(mesh);
                    snowParticles.splice(i, 1);
                    snowParticleVelocities.splice(i, 1);
                }
            });
            if (mixer && isPlaying && planData.frames[Math.floor(currentFrame)] && ['move', 'move_to_ball', 'move_ball', 'push', 'roll', 'roll_ball'].includes(planData.frames[Math.floor(currentFrame)].type)) {
                mixer.update(delta);
            }
            renderer.render(scene, camera);
        }

        const controlPanel = document.getElementById('controlPanel');
        let isDragging = false, currentX, currentY, isResizing = false, startX, startY, startWidth, startHeight;

        controlPanel.addEventListener('mousedown', e => {
            if (e.target.id === 'minimizeBtn') return;
            if (e.target.id === 'resizeHandle') {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(document.defaultView.getComputedStyle(controlPanel).width, 10);
                startHeight = parseInt(document.defaultView.getComputedStyle(controlPanel).height, 10);
                controlPanel.style.cursor = 'se-resize';
            } else {
                isDragging = true;
                currentX = e.clientX - parseFloat(controlPanel.style.left || 0);
                currentY = e.clientY - parseFloat(controlPanel.style.top || 0);
                controlPanel.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', e => {
            if (isDragging) {
                let newLeft = e.clientX - currentX;
                let newTop = e.clientY - currentY;
                newLeft = Math.max(0, Math.min(newLeft, window.innerWidth * 0.35 - controlPanel.offsetWidth));
                newTop = Math.max(40, Math.min(newTop, window.innerHeight * 0.5 - controlPanel.offsetHeight));
                controlPanel.style.left = `${newLeft}px`;
                controlPanel.style.top = `${newTop}px`;
                controlPanel.style.transform = 'none';
            } else if (isResizing) {
                const width = startWidth + (e.clientX - startX);
                const height = startHeight + (e.clientY - startY);
                controlPanel.style.width = `${Math.max(200, Math.min(400, width))}px`;
                controlPanel.style.height = `${Math.max(150, Math.min(600, height))}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            isResizing = false;
            controlPanel.style.cursor = 'move';
        });

        document.getElementById('minimizeBtn').addEventListener('click', () => {
            controlPanel.classList.toggle('minimized');
            if (controlPanel.classList.contains('minimized')) {
                document.getElementById('minimizeBtn').textContent = '+';
                document.getElementById('problemFile').style.display = 'none';
                document.getElementById('planFile').style.display = 'none';
                document.querySelectorAll('#controlPanel button, #controlPanel label, #controlPanel input[type="range"]').forEach(el => el.style.display = 'none');
                document.getElementById('resizeHandle').style.display = 'none';
            } else {
                document.getElementById('minimizeBtn').textContent = '-';
                document.getElementById('problemFile').style.display = 'block';
                document.getElementById('planFile').style.display = 'block';
                document.querySelectorAll('#controlPanel button, #controlPanel label, #controlPanel input[type="range"]').forEach(el => el.style.display = 'block');
                document.getElementById('resizeHandle').style.display = 'block';
            }
        });

        document.getElementById('menuBtn').addEventListener('click', () => {
            const menu = document.getElementById('menuDropdown');
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        });

        document.getElementById('helpBtn').addEventListener('click', () => {
            showPopup('helpPopup', 'helpMessage', document.getElementById('helpMessage').innerHTML);
            document.getElementById('menuDropdown').style.display = 'none';
        });
        document.getElementById('metricsBtn').addEventListener('click', () => {
            showPopup('metricsPopup', 'metricsMessage', getMetrics().display);
            document.getElementById('menuDropdown').style.display = 'none';
        });
        document.getElementById('aboutBtn').addEventListener('click', () => {
            showPopup('aboutPopup', 'aboutMessage', document.getElementById('aboutMessage').innerHTML);
            document.getElementById('menuDropdown').style.display = 'none';
        });

        document.getElementById('errorClose').addEventListener('click', () => hidePopup('errorPopup'));
        document.getElementById('helpClose').addEventListener('click', () => hidePopup('helpPopup'));
        document.getElementById('metricsClose').addEventListener('click', () => hidePopup('metricsPopup'));
        document.getElementById('aboutClose').addEventListener('click', () => hidePopup('aboutPopup'));
        document.getElementById('exportMetrics').addEventListener('click', () => {
            exportToExcel();
        });

        document.getElementById('problemFile').addEventListener('change', selectFiles);
        document.getElementById('planFile').addEventListener('change', selectFiles);

        document.getElementById('playPause').addEventListener('click', () => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to start the animation.');
                return;
            }
            isPlaying = !isPlaying;
            if (isPlaying) {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
                playPauseText.textContent = 'Pause';
                if (!startTime) startTime = performance.now();
            } else {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                playPauseText.textContent = 'Play';
            }
        });

        document.getElementById('stepForward').addEventListener('click', () => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to step through the plan.');
                return;
            }
            if (!isPlaying && currentFrame < planData.frames.length - SUBSTEPS) {
                currentFrame = Math.min(currentFrame + SUBSTEPS, planData.frames.length - 1);
                document.getElementById('step').value = Math.floor(currentFrame / SUBSTEPS);
                updateFrame(planData.frames[Math.floor(currentFrame)]);
            }
        });

        document.getElementById('stepBackward').addEventListener('click', () => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to step through the plan.');
                return;
            }
            if (!isPlaying && currentFrame >= SUBSTEPS) {
                currentFrame -= SUBSTEPS;
                document.getElementById('step').value = Math.floor(currentFrame / SUBSTEPS);
                updateFrame(planData.frames[Math.floor(currentFrame)]);
            }
        });

        document.getElementById('reset').addEventListener('click', () => resetScene(true));

        document.getElementById('speed').addEventListener('input', e => speed = Number(e.target.value));

        document.getElementById('snowSpeed').addEventListener('input', e => snowSpeed = Number(e.target.value));

        document.getElementById('step').addEventListener('input', e => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to use the step slider.');
                return;
            }
            currentFrame = Number(e.target.value) * SUBSTEPS;
            isPlaying = false;
            playIcon.style.display = 'block';
            pauseIcon.style.display = 'none';
            playPauseText.textContent = 'Play';
            updateFrame(planData.frames[Math.floor(currentFrame)]);
        });

        window.addEventListener('resize', () => {
            camera.aspect = 0.65 * window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.65, window.innerHeight - 70);
            controlPanel.style.left = '10px';
            controlPanel.style.top = '50px';
        });

        window.onload = async function() {
            await initCoreThreeJs();
            await initStaticEnvironment(defaultProblemData);
            renderer.render(scene, camera);
        };
    </script>
</body>
</html>