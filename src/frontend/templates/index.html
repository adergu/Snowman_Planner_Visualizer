<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowman Planner Visualizer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import map for Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
            }
        }
    </script>
     <link rel="stylesheet" href="../static/css/styles.css">
    <style>
        /* Keyframe animations for fade-in and pulse effects */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        /* Styling for control panel buttons */
        .control-btn {
            transition: all 0.3s ease;
            min-width: 60px;
            display: flex; /* Use flexbox to align icon and text */
            align-items: center; /* Vertically center */
            justify-content: center; /* Horizontally center */
            gap: 4px; /* Space between icon and text */
            padding: 8px 12px; /* Adjust padding for better look with icon+text */
        }
        .control-btn:hover { transform: scale(1.1); }
        .control-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .control-btn svg { width: 20px; height: 20px; fill: currentColor; } /* Style for SVG icons */

        /* Styling for the main control panel */
        #controlPanel {
            position: absolute;
            top: 50px;
            left: 10px;
            background: rgba(75, 85, 99, 0.8);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: move;
            user-select: none;
            resize: both; /* Allows resizing */
            min-width: 200px;
            min-height: 150px;
            max-width: 400px;
            max-height: 600px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        /* Style for minimized control panel */
        #controlPanel.minimized { height: 40px; min-height: 40px; }
        /* Resize handle for the control panel */
        #resizeHandle { width: 15px; height: 15px; position: absolute; bottom: 0; right: 0; cursor: se-resize; background: #4B5563; }
        /* Minimize button for the control panel */
        #minimizeBtn { position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; background: #EF4444; border-radius: 50%; text-align: center; line-height: 20px; color: white; cursor: pointer; }
        #minimizeBtn:hover { background: #DC2626; }
        /* Canvas positioning */
        #canvas { position: absolute; top: 40px; right: 0; width: 65%; height: calc(100% - 40px - 30px); }
        #timelineCanvas { display: none; } /* Not used in this version */
        /* Header styling */
        header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to right, #1e3a8a, #4b5cb6);
            color: white;
            padding: 5px 20px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 18px;
            font-weight: bold;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            height: 40px;
            line-height: 30px;
        }
        /* Footer styling */
        footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to right, #1e3a8a, #4b5cb6);
            color: white;
            padding: 5px 20px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            z-index: 20;
            height: 30px;
            line-height: 20px;
        }
        /* Styling for pop-up messages */
        #errorPopup, #helpPopup, #metricsPopup, #aboutPopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(75, 85, 99, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none; /* Hidden by default */
            max-width: 400px;
            text-align: left;
        }
        #errorPopup { background: rgba(255, 75, 75, 0.9); } /* Red background for errors */
        /* Pop-up button styling */
        #errorPopup button, #helpPopup button, #metricsPopup button, #aboutPopup button {
            background: #2563EB;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        #errorPopup button:hover, #helpPopup button:hover, #metricsPopup button:hover, #aboutPopup button:hover { background: #1D4ED8; }
        /* Menu button styling */
        #menuBtn { position: absolute; top: 5px; right: 30px; width: 20px; height: 20px; background: #2563EB; border-radius: 50%; text-align: center; line-height: 20px; color: white; cursor: pointer; }
        #menuBtn:hover { background: #1D4ED8; }
        /* Menu dropdown styling */
        #menuDropdown {
            position: absolute;
            top: 30px;
            right: 10px;
            background: rgba(75, 85, 99, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: none; /* Hidden by default */
            z-index: 100;
        }
        #menuDropdown button { display: block; width: 100%; padding: 10px; color: white; background: none; border: none; text-align: left; cursor: pointer; }
        #menuDropdown button:hover { background: rgba(255, 255, 255, 0.1); }
    </style>
</head>
<body class="m-0 bg-gradient-to-b from-blue-900 to-gray-900">
    <div id="app" class="relative w-full h-screen">
        <header>
            Snowman Planner Visualizer - Intelligent System Planning
            <div id="menuBtn">☰</div>
            <div id="menuDropdown">
                <button id="helpBtn">Help</button>
                <button id="metricsBtn">Metrics</button>
                <button id="aboutBtn">About</button>
            </div>
        </header>
        <canvas id="canvas"></canvas>
        <div id="controlPanel" class="animate-[fadeIn_0.5s]">
            <div id="minimizeBtn">-</div>
            <label class="text-white text-lg font-bold mb-2">Choose Files</label>
            <div class="flex flex-col gap-2">
                <label class="text-gray-300 text-sm">Problem File (.pddl):</label>
                <input id="problemFile" type="file" accept=".pddl" class="mb-3 text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                <label class="text-gray-300 text-sm">Plan File (.txt/.plan):</label>
                <input id="planFile" type="file" accept=".txt,.plan" class="mb-3 text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-blue-600 file:text-white hover:file:bg-blue-700">
            </div>
            <div class="flex flex-wrap justify-between gap-2">
                <button id="stepBackward" class="control-btn bg-blue-500 hover:bg-blue-600 text-white rounded-full shadow-md" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z"/></svg>
                    <span>Prev</span>
                </button>
                <button id="playPause" class="control-btn bg-green-500 hover:bg-green-600 text-white rounded-full shadow-md" disabled>
                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                    <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    <span id="playPauseText">Play</span>
                </button>
                <button id="stepForward" class="control-btn bg-blue-500 hover:bg-blue-600 text-white rounded-full shadow-md" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M8.59 16.59L13.17 12l-4.58-4.59L10 6l6 6-6 6z"/></svg>
                    <span>Next</span>
                </button>
                <button id="reset" class="control-btn bg-red-500 hover:bg-red-600 text-white rounded-full shadow-md" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V2L7 7l5 5V9c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                    <span>Reset</span>
                </button>
            </div>
            <div class="flex items-center gap-2">
                <label class="text-gray-300 text-sm">Speed:</label>
                <input id="speed" type="range" min="0.5" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg cursor-pointer">
            </div>
            <div class="flex items-center gap-2">
                <label class="text-gray-300 text-sm">Snow Speed:</label>
                <input id="snowSpeed" type="range" min="0.1" max="0.5" step="0.1" value="0.2" class="w-full h-2 bg-gray-700 rounded-lg cursor-pointer">
            </div>
            <div class="flex items-center gap-2">
                <label class="text-gray-300 text-sm">Step:</label>
                <input id="step" type="range" min="0" max="0" step="1" value="0" class="w-full h-2 bg-gray-700 rounded-lg cursor-pointer" disabled>
            </div>
            <div id="resizeHandle"></div>
        </div>
        <!-- Pop-up for error messages -->
        <div id="errorPopup">
            <p id="errorMessage"></p>
            <button id="errorClose">Close</button>
        </div>
        <!-- Pop-up for help information -->
        <div id="helpPopup">
            <p id="helpMessage">
                <strong>How to Use the Snowman Planner Visualizer:</strong><br>
                1. Select a problem file (.pddl) using the "Problem File" input.<br>
                2. Select a plan file (.txt or .plan) using the "Plan File" input.<br>
                3. Use the "Play/Pause" button to start or pause the animation.<br>
                4. Use "Next" and "Prev" to step through the plan manually.<br>
                5. Adjust the "Speed" slider to control animation speed.<br>
                6. Adjust the "Snow Speed" slider to control snowflake fall speed.<br>
                7. Use the "Step" slider to jump to a specific step.<br>
                8. Click "Reset" to clear the scene and start over.<br>
                9. Drag the control panel to reposition it, resize it using the bottom-right corner, or minimize it using the red button.
            </p>
            <button id="helpClose">Close</button>
        </div>
        <!-- Pop-up for metrics -->
        <div id="metricsPopup">
            <p id="metricsMessage"></p>
            <button id="metricsClose">Close</button>
        </div>
        <!-- Pop-up for about information -->
        <div id="aboutPopup">
            <p id="aboutMessage">
                <strong>About Snowman Planner Visualizer:</strong><br>
                This project visualizes a PDDL-based snowman-building plan, developed by MSc AI and CS students at Unical for the 2025/2026 academic year. It uses Three.js for 3D rendering and Tailwind CSS for styling, allowing users to animate and interact with planning solutions in a 5x5 grid environment.
            </p>
            <button id="aboutClose">Close</button>
        </div>
        <footer>© Unical 2025/2026 MSc AI and CS student's</footer>
    </div>
    <script type="module">
        // Import necessary Three.js modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Configuration constants
        const RADIUS = { 0: 0.15, 1: 0.25, 2: 0.35 }; // Radii for small, medium, large balls
        const SUBSTEPS = 10; // Number of animation substeps per plan action
        const GOAL_POS = '2,0'; // The target grid position for the snowman (X,Y string in 0-indexed) - Reverted to original
        const SNOW_COLOR = 0xE0FFFF; // Color for cells with snow (Light Cyan)
        const REGULAR_GRID_COLOR = 0x90EE90; // Default color for non-snow grid cells (Light Green)
        const UNTOUCHED_GRID_COLOR = 0x556B2F; // Dark Olive Green for non-snow, non-goal, non-special grid cells
        // Special positions from the Python script (0-indexed)
        const SPECIAL_GRID_POSITIONS = ['1,1', '1,3', '3,1', '3,3'];
        const CHARACTER_DEFAULT_COLOR = 0x8B4513; // SaddleBrown for soldier model
        const FALLBACK_CHARACTER_COLOR = 0xFFFF00; // Yellow for fallback box character

        // Global state variables for the visualization
        // Default problem state for initial display of static environment
        let defaultProblemData = {
            grid_size: 5,
            snow: Object.fromEntries(Array(5).fill().flatMap((_, x) => Array(5).fill().map((_, y) => [[x, y].join(','), x === 0 || x === 4]))),
            balls: {}, // No balls initially
            ball_size: {}, // No ball sizes initially
            character: '2,1' // Default character position for static display
        };
        let planData = { problem: defaultProblemData, frames: [], isNumeric: false }; // planData will be updated on file load

        let currentFrame = 0; // Current frame in the animation sequence
        let isPlaying = false; // Animation play/pause state
        let speed = 1; // Animation playback speed multiplier
        let snowSpeed = 0.2; // Speed of falling snowflakes
        // Three.js scene elements
        let scene, camera, renderer, controls,
            grid = {}, // Stores references to grid plane meshes
            balls = {}, // Stores references to ball meshes
            character, // Reference to character mesh/model
            mixer, // Animation mixer for character
            particles, particleVelocities = [], // General particle system (not used for snow)
            snowParticles = [], snowParticleVelocities = [], // Snow particle system
            pathLine, // Path line (currently unused)
            spotlight; // Spotlight following character
        let forbiddenIcons = {}; // To store references to the 3D forbidden icons

        const clock = new THREE.Clock(); // Clock for animation timing
        let currentTime = 0; // Current elapsed time of the plan
        let startTime = null; // Timestamp when playback started
        // Removed snowman and snowmanInstance as they are no longer used for the visual snowman

        // Declare problemFile and planFile globally
        let problemFile = null;
        let planFile = null;

        // UI elements for play/pause icon and text toggle
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const playPauseText = document.getElementById('playPauseText');

        /**
         * Shows a specified pop-up message.
         * @param {string} popupId - The ID of the pop-up element to show.
         * @param {string} messageId - The ID of the element within the pop-up to display the message.
         * @param {string} message - The message content (can include HTML).
         */
        function showPopup(popupId, messageId, message) {
            // Hide all pop-ups first
            document.querySelectorAll('#errorPopup, #helpPopup, #metricsPopup, #aboutPopup').forEach(p => p.style.display = 'none');
            const popup = document.getElementById(popupId);
            const messageEl = document.getElementById(messageId);
            messageEl.innerHTML = message; // Use innerHTML to preserve formatting
            popup.style.display = 'block';
        }

        /**
         * Hides a specified pop-up message.
         * @param {string} popupId - The ID of the pop-up element to hide.
         */
        function hidePopup(popupId) {
            document.getElementById(popupId).style.display = 'none';
        }

        /**
         * Parses a location string (e.g., "loc_3_1") into a [row, col] array.
         * Adjusts for 0-based indexing if input is 1-based.
         * @param {string} loc - The location string.
         * @returns {number[]} - An array [row, col].
         * @throws {Error} If the location format is invalid.
         */
        function parseLoc(loc) {
            try {
                const parts = loc.split('_');
                if (parts.length < 3) throw new Error(`Invalid location format: ${loc}`);
                return [parseInt(parts[1]) - 1, parseInt(parts[2]) - 1]; // Convert to 0-based index
            } catch (e) {
                console.error(`Error parsing location '${loc}': ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error parsing location '${loc}': ${e.message}`);
                throw e;
            }
        }

        /**
         * Parses the content of a PDDL problem file to extract initial state information.
         * @param {string} content - The PDDL problem file content.
         * @returns {object} - An object containing parsed problem data (snow, balls, ball_size, character, grid_size, domain).
         * @throws {Error} If the problem file is empty or contains invalid data.
         */
        function parseProblem(content) {
            try {
                if (!content.trim()) throw new Error("Problem file is empty");

                let snow = {}, balls = {}, ballSize = {}, character = null;
                let gridPositions = new Set(); // To determine grid size dynamically
                let domain = 'unknown';

                // Extract domain name
                const domainMatch = content.match(/:domain (\S+)/);
                if (domainMatch) domain = domainMatch[1];

                // Parse snow locations based on location_type (numeric domain)
                const locTypeRegex = /\(= \(location_type (\S+)\) (\d+)\)/g;
                let match;
                while ((match = locTypeRegex.exec(content)) !== null) {
                    const loc = match[1];
                    const t = match[2];
                    const coord = parseLoc(loc);
                    snow[coord.join(',')] = (t === '1'); // '1' indicates snow
                    gridPositions.add(coord.join(','));
                }

                // Parse snow locations (classic domain)
                const snowRegex = /\(snow (\S+)\)/g;
                while ((match = snowRegex.exec(content)) !== null) {
                    const loc = match[1];
                    const coord = parseLoc(loc);
                    snow[coord.join(',')] = true;
                    gridPositions.add(coord.join(','));
                }

                // Parse ball positions
                const ballAtRegex = /\(ball_at (\S+) (\S+)\)/g;
                while ((match = ballAtRegex.exec(content)) !== null) {
                    const [_, ball, loc] = match;
                    gridPositions.add(parseLoc(loc).join(','));
                    balls[ball] = parseLoc(loc);
                }

                // Parse ball sizes (numeric domain)
                const ballSizeNumRegex = /\(= \(ball_size (\S+)\) (\d+)\)/g;
                while ((match = ballSizeNumRegex.exec(content)) !== null) {
                    const [_, ball, size] = match;
                    const sizeInt = parseInt(size);
                    if (![0, 1, 2].includes(sizeInt)) throw new Error(`Invalid ball size ${size} for ball ${ball}. Must be 0, 1, or 2.`);
                    ballSize[ball] = sizeInt;
                }

                // Parse ball sizes (classic domain)
                const ballSizeClassicRegex = /\(ball_size_(small|medium|large) (\S+)\)/g;
                while ((match = ballSizeClassicRegex.exec(content)) !== null) {
                    const [_, sizeStr, ball] = match;
                    const sizeMap = { 'small': 0, 'medium': 1, 'large': 2 };
                    ballSize[ball] = sizeMap[sizeStr.toLowerCase()];
                }

                // Parse character position
                const charMatch = content.match(/\(character_at (\S+)\)/);
                if (charMatch) {
                    character = parseLoc(charMatch[1]);
                    gridPositions.add(character.join(','));
                }

                // Basic validation
                if (Object.keys(balls).length === 0) console.warn("No balls found in problem file. This might be expected for some initial states.");
                if (!character) throw new Error("No character position found in problem file.");

                // Assign default size 0 if not specified for a ball
                for (let ball in balls) {
                    if (!(ball in ballSize)) ballSize[ball] = 0;
                }

                // Determine grid size based on max coordinates found
                let gridSize = 5; // Default grid size
                if (gridPositions.size > 0) {
                    const coords = Array.from(gridPositions).map(c => c.split(',').map(Number));
                    const maxR = Math.max(...coords.map(c => c[0]));
                    const maxC = Math.max(...coords.map(c => c[1]));
                    gridSize = Math.max(maxR, maxC) + 1;
                }

                // Ensure all grid cells have a snow state (default to false if not specified)
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (!(r + ',' + c in snow)) snow[r + ',' + c] = false;
                    }
                }
                console.log("[parseProblem] Parsed problem data:", { snow, balls, ball_size: ballSize, character: character.join(','), grid_size: gridSize, domain });
                return { snow, balls, ball_size: ballSize, character: character.join(','), grid_size: gridSize, domain };
            } catch (e) {
                console.error(`Error parsing problem file: ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error parsing problem file: ${e.message}`);
                throw e;
            }
        }

        /**
         * Parses the content of a plan file into an array of action strings.
         * @param {string} content - The plan file content.
         * @returns {string[]} - An array of parsed plan steps.
         * @throws {Error} If the plan file is empty or contains no valid actions.
         */
        function parsePlan(content) {
            try {
                if (!content.trim()) throw new Error("Plan file is empty");

                const steps = [];
                const lines = content.trim().split('\n');
                for (let line of lines) {
                    line = line.trim();
                    // Skip empty lines or comments
                    if (!line || line.startsWith(';')) continue;

                    // Remove timestamp (e.g., "0.001: ") and parentheses
                    let cleanedLine = line.replace(/^\d+\.\d+:\s*/, '').replace(/^\d+[.:]?\s*/, '');
                    if (cleanedLine.startsWith('(') && cleanedLine.endsWith(')')) {
                        cleanedLine = cleanedLine.slice(1, -1).trim();
                    }
                    // Only add lines that look like valid actions
                    if (cleanedLine && ['move', 'move_to', 'move_ball', 'push', 'roll', 'roll_ball', 'goal', 'move_character'].some(k => cleanedLine.toLowerCase().includes(k))) {
                        steps.push(cleanedLine);
                    }
                }

                if (steps.length === 0) throw new Error("No valid actions found in plan file.");
                console.log("[parsePlan] Parsed plan steps:", steps);
                return steps;
            } catch (e) {
                console.error(`Error parsing plan file: ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error parsing plan file: ${e.message}`);
                throw e;
            }
        }

        /**
         * Builds a sequence of animation frames based on the problem and plan.
         * Each frame represents a snapshot of the scene at a given substep.
         * This function applies the "good snowman rule" for ball sizing at the goal.
         * It now *allows* movement into forbidden cells if the plan dictates it,
         * aligning with the Python visualizer's behavior.
         * @param {object} prob - Parsed problem data.
         * @param {string[]} plan - Parsed plan actions.
         * @returns {object[]} - An array of frame objects.
         * @throws {Error} If there's an error during frame building.
         */
        function buildFrames(prob, plan) {
            try {
                const frames = [];
                // Deep copy initial state
                const state = {
                    snow: { ...prob.snow },
                    balls: Object.fromEntries(Object.entries(prob.balls).map(([k, v]) => [k, v.join(',')])), // Store ball positions as strings
                    ball_size: { ...prob.ball_size },
                    character: prob.character,
                    grid_size: prob.grid_size,
                    isNumeric: prob.domain.includes('snowman_numeric') // Check if domain is numeric
                };

                // Add initial frame
                frames.push({
                    type: 'initial',
                    balls: { ...state.balls },
                    ball_size: { ...state.ball_size },
                    snow: { ...state.snow },
                    character: state.character,
                    grid_size: state.grid_size,
                    time: 0,
                    alpha: 0 // Animation progress (0 to 1)
                });

                let step_count = 0;
                for (let action of plan) {
                    const parts = action.split(/\s+/); // Split action into parts
                    let currentCharacterPos = state.character; // Store character pos before action
                    let currentBallPos = { ...state.balls }; // Store ball pos before action

                    try {
                        if (['move_character', 'move', 'move_to'].includes(parts[0])) {
                            // Handle character movement
                            if (parts.length < 3) throw new Error(`Invalid move action: ${action}`);
                            const start = parseLoc(parts[1]);
                            const end = parseLoc(parts[2]);
                            const endCoordString = end.join(',');
                            const direction = parts.length > 3 ? parts[3] : null;

                            // No explicit "snap back" or error prevention here to match Python's visualization
                            // The character will move to the 'end' position as dictated by the plan.
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'move', // Always 'move', no 'error_move' type
                                    start: start.join(','),
                                    end: end.join(','), // Character moves to the planned end
                                    alpha,
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: currentCharacterPos,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    direction
                                });
                            }
                            state.character = end.join(','); // Update character's state
                        } else if (['move_ball', 'push', 'roll', 'roll_ball'].includes(parts[0])) {
                            // Handle ball movement (pushing/rolling)
                            if (parts.length < 5) throw new Error(`Invalid move_ball action: ${action}`);
                            const [_, ball, fromCell, midCell, toCell] = parts;
                            const start = parseLoc(fromCell);
                            const end = parseLoc(toCell);
                            const endCoordString = end.join(',');
                            const direction = parts.length > 5 ? parts[5] : null;

                            // Character moves to the ball's start position first
                            const charStart = state.character;
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'move_to_ball',
                                    start: charStart,
                                    end: start.join(','),
                                    alpha,
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    direction
                                });
                            }
                            state.character = start.join(','); // Character is now at the ball's start for the next sub-action

                            // Animate the ball moving
                            // No explicit "snap back" or error prevention here to match Python's visualization
                            // The ball will move to the 'end' position as dictated by the plan.
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'move_ball', // Always 'move_ball', no 'error_move_ball' type
                                    ball,
                                    start: start.join(','),
                                    end: end.join(','), // Ball moves to the planned end
                                    alpha,
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    direction
                                });
                            }
                            state.balls[ball] = end.join(','); // Update ball's state

                            // If snow is present at the destination, increase ball size and remove snow
                            if (state.snow[end.join(',')] && (state.isNumeric || !state.isNumeric)) {
                                state.ball_size[ball] = Math.min(state.ball_size[ball] + 1, 2); // Max size is 2 (large)
                                state.snow[end.join(',')] = false; // Snow is consumed
                            }
                        } else if (parts[0] === 'goal') {
                            // Handle the 'goal' action, applying the good snowman rule
                            const ballsAtGoal = Object.entries(state.balls).filter(([_, pos]) => pos === GOAL_POS).map(([b]) => b);
                            console.log(`Processing goal action at step ${step_count + 1}, balls at ${GOAL_POS}: ${ballsAtGoal.length}`);

                            // IMPORTANT: Do NOT reassign ball_size here.
                            // The visual stacking will be handled in updateFrame based on current sizes.
                            if (ballsAtGoal.length >= 3) {
                                // Ensure all balls intended for the snowman are at the goal position
                                ballsAtGoal.forEach(ballName => {
                                    state.balls[ballName] = GOAL_POS;
                                });
                            }

                            // Add frames for the goal state
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'goal',
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size }, // Pass current ball sizes
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    alpha
                                });
                            }
                        } else {
                            // Handle unknown actions (stay static)
                            console.warn(`Unknown action '${action}' on step ${step_count + 1}`);
                            for (let t = 0; t < SUBSTEPS; t++) {
                                const alpha = t / (SUBSTEPS - 1);
                                frames.push({
                                    type: 'static',
                                    balls: { ...state.balls },
                                    ball_size: { ...state.ball_size },
                                    snow: { ...state.snow },
                                    character: state.character,
                                    grid_size: state.grid_size,
                                    time: step_count + alpha,
                                    alpha
                                });
                            }
                        }
                        step_count++;
                    } catch (e) {
                        console.error(`Error processing action '${action}' on step ${step_count + 1}: ${e}`);
                        showPopup('errorPopup', 'errorMessage', `Error processing action '${action}' on step ${step_count + 1}: ${e.message}`);
                        // Add error frames to indicate a problem
                        for (let t = 0; t < SUBSTEPS; t++) {
                            const alpha = t / (SUBSTEPS - 1);
                            frames.push({
                                type: 'error',
                                balls: { ...state.balls },
                                ball_size: { ...state.ball_size },
                                snow: { ...state.snow },
                                character: state.character,
                                grid_size: state.grid_size,
                                time: step_count + alpha,
                                alpha
                            });
                        }
                        step_count++;
                    }
                }
                console.log(`Total frames generated: ${frames.length}, isNumeric: ${state.isNumeric}`);
                return frames;
            } catch (e) {
                console.error(`Error building frames: ${e}`);
                showPopup('errorPopup', 'errorMessage', `Error building frames: ${e.message}`);
                throw e;
            }
        }

        /**
         * Reads a file as text.
         * @param {File} file - The file to read.
         * @returns {Promise<string>} - A promise that resolves with the file content.
         */
        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
                reader.readAsText(file);
            });
        }

        /**
         * Handles file selection and initiates loading of problem and plan files.
         * @param {Event} e - The change event from the file input.
         */
        async function selectFiles(e) {
            const problemInput = document.getElementById('problemFile');
            const planInput = document.getElementById('planFile');
            const changedInput = e.target.id; // Identify which input triggered the event

            console.log(`File input changed: ${changedInput}`);

            // Update global file references
            if (changedInput === 'problemFile' && problemInput.files[0]) {
                if (!problemInput.files[0].name.endsWith('.pddl')) {
                    console.error('Invalid problem file selected');
                    showPopup('errorPopup', 'errorMessage', 'Please select a valid problem file (.pddl).');
                    problemInput.value = ''; // Clear invalid file
                    problemFile = null;
                    return;
                }
                problemFile = problemInput.files[0];
                console.log(`Problem file selected: ${problemFile.name}`);
            } else if (changedInput === 'planFile' && planInput.files[0]) {
                if (!planInput.files[0].name.endsWith('.txt') && !planInput.files[0].name.endsWith('.plan')) {
                    console.error('Invalid plan file selected');
                    showPopup('errorPopup', 'errorMessage', 'Please select a valid plan file (.txt or .plan).');
                    planInput.value = ''; // Clear invalid file
                    planFile = null;
                    return;
                }
                planFile = planInput.files[0];
                console.log(`Plan file selected: ${planFile.name}`);
            }

            // Only attempt to load files if both are selected
            if (problemFile && planFile) {
                console.log('Both files selected, attempting to load');
                try {
                    // Reset scene to clear any existing dynamic state
                    resetScene(false); // Pass false to avoid resetting file inputs
                    const [problemContent, planContent] = await Promise.all([
                        readFile(problemFile),
                        readFile(planFile)
                    ]);
                    await loadFiles(problemContent, planContent, problemFile.name, planFile.name);
                    console.log('Files loaded successfully, rendering initial frame');
                    // Force render the first frame
                    if (planData.frames.length > 0) {
                        updateFrame(planData.frames[0]);
                        renderer.render(scene, camera);
                    }
                } catch (err) {
                    console.error(`Error reading files: ${err.message}`);
                    showPopup('errorPopup', 'errorMessage', `Error reading files: ${err.message}`);
                    resetScene(false); // Reset without clearing files
                }
            } else {
                console.log('Waiting for both files to be selected');
                // Disable controls until both files are loaded
                ['playPause', 'stepForward', 'stepBackward', 'reset', 'step'].forEach(id => {
                    document.getElementById(id).disabled = true;
                });
            }
        }

        /**
         * Loads and processes the problem and plan files.
         * @param {string} problemContent - Content of the PDDL problem file.
         * @param {string} planContent - Content of the plan file.
         * @param {string} problemFileName - Name of the problem file.
         * @param {string} planFileName - Name of the plan file.
         * @returns {Promise<void>}
         */
        async function loadFiles(problemContent, planContent, problemFileName, planFileName) {
            try {
                console.log(`Loading files: ${problemFileName}, ${planFileName}`);
                startTime = performance.now(); // Reset start time for metrics
                const problem = parseProblem(problemContent);
                const plan = parsePlan(planContent);
                planData = {
                    problem,
                    frames: buildFrames(problem, plan),
                    isNumeric: problem.domain.includes('snowman_numeric')
                };
                currentFrame = 0;
                isPlaying = false;
                currentTime = 0;

                console.log("Parsed problem data (initial state):", planData.problem); // Debug log
                console.log("First frame data:", planData.frames[0]); // Debug log

                // Update UI controls
                document.getElementById('step').max = Math.max(0, Math.floor(planData.frames.length / SUBSTEPS) - 1);
                document.getElementById('step').value = 0;
                document.getElementById('step').disabled = false;
                ['playPause', 'stepForward', 'stepBackward', 'reset'].forEach(id => document.getElementById(id).disabled = false);
                playIcon.style.display = 'block'; // Show play icon
                pauseIcon.style.display = 'none'; // Hide pause icon
                playPauseText.textContent = 'Play'; // Set text to Play

                console.log('Clearing existing dynamic scene objects before re-initialization.');
                clearDynamicSceneObjects(); // Clear previous dynamic scene objects
                console.log('Initializing dynamic scene objects with loaded data.');
                await initDynamicSceneObjects(planData.problem); // Setup dynamic scene based on loaded problem data
                console.log(`Dynamic scene initialized, frames: ${planData.frames.length}`);
                console.log("[loadFiles] Current state of 'balls' (Three.js meshes) after initDynamicSceneObjects:", Object.keys(balls));


                if (planData.frames.length > 0) {
                    console.log('Rendering first frame');
                    updateFrame(planData.frames[0]); // Update scene to first frame
                    renderer.render(scene, camera); // Force render
                }
            }
            catch (err) {
                console.error('Error loading plan:', err);
                showPopup('errorPopup', 'errorMessage', `Error loading plan: ${err.message}`);
                resetScene(false); // Reset without clearing files
            }
        }

        /**
         * Creates a 3D barrier icon for forbidden grid cells.
         * @returns {THREE.Group} A Three.js group containing the barrier parts.
         */
        function createForbiddenIcon() {
            const barrierGroup = new THREE.Group();
            const barrierMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.5, metalness: 0.1 }); // Red color

            // Base of the barrier (a thin red box)
            const baseGeometry = new THREE.BoxGeometry(0.8, 0.05, 0.2);
            const baseMesh = new THREE.Mesh(baseGeometry, barrierMaterial);
            baseMesh.position.y = 0.025; // Slightly above the grid
            baseMesh.castShadow = true;
            baseMesh.receiveShadow = true;
            barrierGroup.add(baseMesh);

            // Two small vertical posts
            const postGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.05);
            const post1 = new THREE.Mesh(postGeometry, barrierMaterial);
            post1.position.set(-0.3, 0.15 + 0.025, 0);
            post1.castShadow = true;
            post1.receiveShadow = true;
            barrierGroup.add(post1);

            const post2 = new THREE.Mesh(postGeometry, barrierMaterial);
            post2.position.set(0.3, 0.15 + 0.025, 0);
            post2.castShadow = true;
            post2.receiveShadow = true;
            barrierGroup.add(post2);

            return barrierGroup;
        }

        /**
         * Clears only the dynamic scene objects (balls, character).
         * The static environment (ground, grid, walls, trees, forbidden icons) remains.
         */
        function clearDynamicSceneObjects() {
            console.log('Clearing dynamic scene objects...');
            const objectsToRemove = [];
            scene.traverse(object => {
                // Check if the object is part of the dynamic scene elements
                if (object.name && (
                    object.name.startsWith('ball_') ||
                    object.name === 'character'
                )) {
                    objectsToRemove.push(object);
                }
            });

            objectsToRemove.forEach(object => {
                // Dispose geometries and materials to free up memory
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => mat.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
                scene.remove(object);
            });

            // Reset global references to ensure they are empty
            balls = {};
            character = null; // Character reference should be re-initialized in initDynamicSceneObjects
            
            if (mixer) { // Stop and clear character animations
                mixer.stopAllAction();
                mixer = null;
            }
            // The spotlight's target might be the character, so reset its target
            if (spotlight) {
                spotlight.target.position.set(defaultProblemData.grid_size / 2, 0, defaultProblemData.grid_size / 2); // Reset to center of grid
                spotlight.position.set(defaultProblemData.grid_size / 2, 3, defaultProblemData.grid_size / 2); // Reset position
            }
            console.log('Dynamic scene objects cleared.');
        }

        /**
         * Initializes the static environment objects (ground, grid, walls, trees, forbidden icons).
         * This runs once on initial page load and when explicitly resetting the static environment.
         * @param {object} problemDataForStatic - Use defaultProblemData for initial static display.
         */
        async function initStaticEnvironment(problemDataForStatic) {
            console.log('Initializing static environment objects...');

            // Clear existing static objects before re-creating them (important for reset)
            const staticObjectsToRemove = [];
            scene.traverse(object => {
                if (object.name && (
                    object.name.startsWith('grid_') ||
                    object.name === 'ground_plane' ||
                    object.name.startsWith('wall_') ||
                    object.name.startsWith('tree_') ||
                    // Forbidden icons are part of static environment, clear if re-initializing static
                    object.name.startsWith('forbidden_icon_')
                )) {
                    staticObjectsToRemove.push(object);
                }
            });
            staticObjectsToRemove.forEach(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) object.material.forEach(m => m.dispose());
                    else object.material.dispose();
                }
                scene.remove(object);
            });
            grid = {}; // Clear grid references
            forbiddenIcons = {}; // Clear forbidden icon references

            // Create Ground Plane
            const groundGeometry = new THREE.PlaneGeometry(problemDataForStatic.grid_size + 2, problemDataForStatic.grid_size + 2);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: SNOW_COLOR, roughness: 0.8, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(problemDataForStatic.grid_size / 2, -0.01, problemDataForStatic.grid_size / 2);
            ground.receiveShadow = true;
            ground.name = 'ground_plane';
            scene.add(ground);
            console.log('Ground added.');

            // Create Grid Planes
            const [goalX, goalY] = GOAL_POS.split(',').map(Number);
            for (let x = 0; x < problemDataForStatic.grid_size; x++) {
                for (let y = 0; y < problemDataForStatic.grid_size; y++) {
                    const coord = `${x},${y}`;
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    let materialColor;

                    if (SPECIAL_GRID_POSITIONS.includes(coord)) {
                        materialColor = 0xFFFFFF; // White for special positions with forbidden icon
                        const icon = createForbiddenIcon();
                        icon.position.set(x + 0.5, 0, y + 0.5);
                        icon.name = `forbidden_icon_${coord}`;
                        scene.add(icon);
                        forbiddenIcons[coord] = icon; // Store for reference
                    } else if (problemDataForStatic.snow[coord]) {
                        materialColor = SNOW_COLOR;
                    } else if (x === goalX && y === goalY) {
                        materialColor = REGULAR_GRID_COLOR;
                    } else {
                        materialColor = UNTOUCHED_GRID_COLOR;
                    }

                    const material = new THREE.MeshStandardMaterial({ color: materialColor, side: THREE.DoubleSide });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.rotation.x = -Math.PI / 2;
                    plane.position.set(x + 0.5, 0, y + 0.5);
                    plane.receiveShadow = true;
                    plane.name = `grid_${coord}`;
                    scene.add(plane);
                    grid[coord] = plane;
                }
            }
            console.log('Grid planes added.');

            // Create Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.7, roughness: 0.3, metalness: 0.5 });
            const wallHeight = 0.5;
            const wallThickness = 0.2;
            const halfGridSize = problemDataForStatic.grid_size / 2;
            [
                { geometry: new THREE.BoxGeometry(problemDataForStatic.grid_size + wallThickness * 2, wallHeight, wallThickness), position: [halfGridSize, wallHeight / 2, -wallThickness / 2], name: 'wall_top' },
                { geometry: new THREE.BoxGeometry(problemDataForStatic.grid_size + wallThickness * 2, wallHeight, wallThickness), position: [halfGridSize, wallHeight / 2, problemDataForStatic.grid_size + wallThickness / 2], name: 'wall_bottom' },
                { geometry: new THREE.BoxGeometry(wallThickness, wallHeight, problemDataForStatic.grid_size + wallThickness * 2), position: [-wallThickness / 2, wallHeight / 2, halfGridSize], name: 'wall_left' },
                { geometry: new THREE.BoxGeometry(wallThickness, wallHeight, problemDataForStatic.grid_size + wallThickness * 2), position: [problemDataForStatic.grid_size + wallThickness / 2, wallHeight / 2, halfGridSize], name: 'wall_right' }
            ].forEach(({ geometry, position, name }) => {
                const wall = new THREE.Mesh(geometry, wallMaterial);
                wall.position.set(...position);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.name = name;
                scene.add(wall);
            });
            console.log('Walls added.');

            // Create Trees
            const treeGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 });
            const treePositions = [
                [-1, 0, -1], [problemDataForStatic.grid_size + 1, 0, -1],
                [-1, 0, problemDataForStatic.grid_size + 1], [problemDataForStatic.grid_size + 1, 0, problemDataForStatic.grid_size + 1],
                [halfGridSize, 0, -1], [halfGridSize, 0, problemDataForStatic.grid_size + 1],
                [-1, 0, halfGridSize], [problemDataForStatic.grid_size + 1, 0, halfGridSize]
            ];
            treePositions.forEach((pos, index) => {
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.set(pos[0], pos[1] + 0.4, pos[2]);
                tree.castShadow = true;
                tree.receiveShadow = true;
                tree.name = `tree_${index}`;
                scene.add(tree);
            });
            console.log('Trees added.');
        }

        /**
         * Initializes or re-initializes only the dynamic 3D objects (balls, character).
         * This is called after files are loaded.
         * @param {object} problemData - The current problem data (initial state).
         * @returns {Promise<void>}
         */
        async function initDynamicSceneObjects(problemData) {
            console.log('[initDynamicSceneObjects] Setting up dynamic scene objects with problem data:', problemData);

            const loader = new GLTFLoader();

            // Load Character GLTF model or use fallback
            if (!character) { // Only load character model if it hasn't been loaded yet
                try {
                    const gltf = await new Promise((resolve, reject) => loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/Soldier.glb', resolve, undefined, reject));
                    character = gltf.scene;
                    character.scale.set(0.4, 0.4, 0.4);
                    character.castShadow = true;
                    character.receiveShadow = true;
                    character.name = 'character';
                    if (gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(character);
                        gltf.animations.forEach(clip => mixer.clipAction(clip).play());
                    }
                    // Set default material color for GLTF model (it might have multiple materials)
                    character.traverse(obj => {
                        if (obj.isMesh && obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(mat => {
                                    if (mat.type === 'MeshStandardMaterial' || mat.type === 'MeshBasicMaterial') {
                                        mat.color.set(CHARACTER_DEFAULT_COLOR);
                                    }
                                });
                            } else {
                                if (obj.material.type === 'MeshStandardMaterial' || obj.material.type === 'MeshBasicMaterial') {
                                    obj.material.color.set(CHARACTER_DEFAULT_COLOR);
                                }
                            }
                        }
                    });
                    console.log('[initDynamicSceneObjects] Character loaded.');
                } catch (e) {
                    console.warn('[initDynamicSceneObjects] Failed to load character model, using fallback (yellow box).', e);
                    character = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.3), new THREE.MeshStandardMaterial({ color: FALLBACK_CHARACTER_COLOR }));
                    character.position.y = 0.4; // Position above ground
                    character.castShadow = true;
                    character.name = 'character';
                }
                scene.add(character);
            }
            // Ensure character is visible by default when dynamic objects are initialized
            if (character) {
                character.visible = true;
            }
            const [cx, cy] = problemData.character.split(',').map(Number);
            character.position.set(cx + 0.5, 0, cy + 0.5);
            console.log(`[initDynamicSceneObjects] Character positioned at (${cx + 0.5}, 0, ${cy + 0.5}).`);

            // Create initial balls based on problemData.balls
            // Ensure any existing balls are removed before re-creating
            for (const ballName in balls) {
                scene.remove(balls[ballName]);
                if (balls[ballName].geometry) balls[ballName].geometry.dispose();
                if (balls[ballName].material) {
                    if (Array.isArray(balls[ballName].material)) balls[ballName].material.forEach(m => m.dispose());
                    else balls[ballName].material.dispose();
                }
                delete balls[ballName];
            }
            balls = {}; // Clear the global balls object to ensure fresh start

            for (let b in problemData.balls) {
                const geometry = new THREE.SphereGeometry(RADIUS[problemData.ball_size[b]], 32, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.2 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                // problemData.balls[b] is already an array [x, y]
                const [x, y] = problemData.balls[b];
                sphere.position.set(x + 0.5, RADIUS[problemData.ball_size[b]], y + 0.5);
                sphere.name = `ball_${b}`;
                scene.add(sphere);
                balls[b] = sphere;
                console.log(`[initDynamicSceneObjects] Added ball ${b} (size ${problemData.ball_size[b]}) at position (${x + 0.5}, ${RADIUS[problemData.ball_size[b]]}, ${y + 0.5}).`);
            }
            console.log("[initDynamicSceneObjects] All initial balls created:", Object.keys(balls));

            // Spotlight (re-add/re-position as it follows dynamic objects)
            if (spotlight) { scene.remove(spotlight); scene.remove(spotlight.target); } // Ensure old one is removed
            spotlight = new THREE.SpotLight(0xffffff, 0, 5, Math.PI / 4, 0.5, 2);
            spotlight.position.set(cx + 0.5, 3, cy + 0.5);
            spotlight.castShadow = true;
            scene.add(spotlight);
            scene.add(spotlight.target);
            console.log('[initDynamicSceneObjects] Spotlight added/re-added.');
        }

        /**
         * Initializes the core Three.js scene, camera, renderer, and controls.
         * This is called once when the page loads.
         * @returns {Promise<void>}
         */
        async function initCoreThreeJs() {
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, 0.65 * window.innerWidth / window.innerHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
                renderer.setSize(window.innerWidth * 0.65, window.innerHeight - 70);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                scene.fog = new THREE.Fog(0x87CEEB, 3, 10);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);

                // Skybox (background)
                const skyboxLoader = new THREE.CubeTextureLoader();
                skyboxLoader.load([
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_px.jpg', // Positive X
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_nx.jpg', // Negative X
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_py.jpg', // Positive Y
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_ny.jpg', // Negative Y
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_pz.jpg', // Positive Z
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/MilkyWay/dark-s_nz.jpg'  // Negative Z
                ], texture => { scene.background = texture; }, undefined, () => { scene.background = new THREE.Color(0x87CEEB); });

                // Orbit Controls for camera interaction
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 2;
                controls.maxDistance = 10;

                // Initial camera position and target (default grid size 5)
                camera.position.set(defaultProblemData.grid_size / 2, 3, defaultProblemData.grid_size);
                controls.target.set(defaultProblemData.grid_size / 2, 0, defaultProblemData.grid_size / 2);

                // Snow particle system (individual snowflakes)
                const snowParticleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                function dropSnowflake() {
                    const size = 0.009 + Math.random() * 0.012;
                    const geometry = new THREE.CircleGeometry(size, 32);
                    const mesh = new THREE.Mesh(geometry, snowParticleMaterial);
                    mesh.position.set(Math.random() * (defaultProblemData.grid_size + 2) - 1, Math.random() * 5 + 3, Math.random() * (defaultProblemData.grid_size + 2) - 1);
                    const velocity = new THREE.Vector3((Math.random() - 0.5) * 0.05 + 0.02 * Math.sin(clock.getElapsedTime()), -snowSpeed, (Math.random() - 0.5) * 0.05 + 0.02 * Math.cos(clock.getElapsedTime()));
                    snowParticles.push(mesh);
                    snowParticleVelocities.push(velocity);
                    scene.add(mesh);
                }
                setInterval(dropSnowflake, 300);

                // Path line (currently not used for visualization)
                const pathGeometry = new THREE.BufferGeometry();
                const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
                pathLine = new THREE.Line(pathGeometry, pathMaterial);
                scene.add(pathLine);

                console.log('Core Three.js setup complete.');
                animate(); // Start the animation loop
            } catch (err) {
                console.error('Core Three.js Initialization error:', err);
                showPopup('errorPopup', 'errorMessage', `Core Three.js Initialization error: ${err.message}`);
            }
        }


        /**
         * Updates the 3D scene based on the current animation frame data.
         * This is where the visual representation of the plan is updated.
         * @param {object} f - The current frame object containing state information.
         */
        function updateFrame(f) {
            try {
                if (!f) return;

                console.log(`[updateFrame] Processing frame: ${Math.floor(currentFrame)}, type: ${f.type}`);
                console.log("[updateFrame] Frame's f.balls state:", f.balls);
                console.log("[updateFrame] Current scene's 'balls' (meshes) before update:", Object.keys(balls));


                // Update grid cell colors based on snow presence and goal position
                const [goalX, goalY] = GOAL_POS.split(',').map(Number);
                for (let x = 0; x < f.grid_size; x++) {
                    for (let y = 0; y < f.grid_size; y++) {
                        const coord = `${x},${y}`;
                        if (grid[coord]) {
                            let newColor;

                            // Always prioritize special grid positions
                            if (SPECIAL_GRID_POSITIONS.includes(coord)) {
                                newColor = 0xFFFFFF; // White for special positions with forbidden icon
                            } else if (f.snow[coord]) {
                                newColor = SNOW_COLOR; // Snowy white if it has snow
                            } else if (x === goalX && y === goalY) {
                                newColor = REGULAR_GRID_COLOR;
                            } else {
                                newColor = UNTOUCHED_GRID_COLOR;
                            }

                            grid[coord].material.color.set(newColor);
                            grid[coord].material.needsUpdate = true;
                        }
                    }
                }

                // Temporarily store balls at goal for stacking logic this frame
                const ballsCurrentlyAtGoal = [];
                for (let b in f.balls) {
                    if (f.balls[b] === GOAL_POS) {
                        ballsCurrentlyAtGoal.push({ name: b, size: f.ball_size[b] });
                    }
                }

                // Sort balls at goal by size (largest to smallest) for stacking
                ballsCurrentlyAtGoal.sort((a, b) => b.size - a.size);

                const [goalCellX, goalCellY] = GOAL_POS.split(',').map(Number);

                // Update ball positions and sizes
                for (let b in f.balls) {
                    if (!balls[b]) {
                        // This should ideally not be hit if initDynamicSceneObjects works correctly for initial state,
                        // but acts as a fallback if a ball appears mid-plan (unlikely for this problem)
                        console.warn(`[updateFrame] Creating ball ${b} dynamically. Should have been initialized.`);
                        const geometry = new THREE.SphereGeometry(RADIUS[f.ball_size[b]], 32, 32);
                        const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.2 });
                        balls[b] = new THREE.Mesh(geometry, material);
                        balls[b].castShadow = true;
                        balls[b].receiveShadow = true;
                        balls[b].name = `ball_${b}`;
                        scene.add(balls[b]);
                    } else {
                        // Update existing ball's geometry if its size has changed
                        if (balls[b].geometry.parameters.radius !== RADIUS[f.ball_size[b]]) {
                            balls[b].geometry.dispose(); // Dispose old geometry
                            balls[b].geometry = new THREE.SphereGeometry(RADIUS[f.ball_size[b]], 32, 32); // Create new geometry
                            console.log(`[updateFrame] Updated geometry for ball: ${b} to size ${f.ball_size[b]} at frame ${Math.floor(currentFrame)}`);
                        }
                    }

                    let posX, posY, posZ;
                    // Special positioning for balls at the goal (snowman stacking)
                    if (f.balls[b] === GOAL_POS) {
                        // Find this ball in the sorted list to get its stacking Y-position
                        let currentHeight = 0;
                        for (let i = 0; i < ballsCurrentlyAtGoal.length; i++) {
                            const stackedBall = ballsCurrentlyAtGoal[i];
                            if (stackedBall.name === b) {
                                posY = currentHeight + RADIUS[stackedBall.size];
                                break;
                            }
                            currentHeight += (RADIUS[stackedBall.size] * 2);
                        }
                        posX = goalCellX + 0.5;
                        posZ = goalCellY + 0.5;
                        balls[b].visible = true; // Ensure individual balls are visible during stacking progress

                    } else if (['move_ball', 'push', 'roll', 'roll_ball'].includes(f.type) && f.ball === b) {
                        // Animate ball movement
                        const [sx, sy] = f.start.split(',').map(Number);
                        const [ex, ey] = f.end.split(',').map(Number);
                        posX = sx + 0.5 + f.alpha * (ex - sx);
                        posZ = sy + 0.5 + f.alpha * (ey - sy);
                        posY = RADIUS[f.ball_size[b]]; // Ball's radius for Y position
                        balls[b].visible = true;
                    }
                    else {
                        // Default positioning for balls not currently moving or at goal
                        const [x, y] = f.balls[b].split(',').map(Number);
                        posX = x + 0.5;
                        posZ = y + 0.5;
                        posY = RADIUS[f.ball_size[b]];
                        balls[b].visible = true;
                    }
                    balls[b].position.set(posX, posY, posZ);
                }

                // Character visibility logic: Hide character if all three balls are at GOAL_POS
                const ballsAtGoalFinalCheck = Object.entries(f.balls).filter(([_, pos]) => pos === GOAL_POS);
                const ballsAtGoalCount = ballsAtGoalFinalCheck.length;
                const sizesAtGoal = new Set(ballsAtGoalFinalCheck.map(([b]) => f.ball_size[b]));
                const isSnowmanFormed = (ballsAtGoalCount === 3 && sizesAtGoal.has(0) && sizesAtGoal.has(1) && sizesAtGoal.has(2));

                if (character) {
                    // Character is hidden only if the snowman is fully formed AND the character is at the goal position.
                    // This implies the character "completes" the snowman and then becomes part of the final scene.
                    // If the character is elsewhere, it remains visible.
                    character.visible = !(isSnowmanFormed && f.character === GOAL_POS);
                }

                // Update character position and rotation (this block should now only run if character.visible is true)
                if (character && character.visible && f.character) { // Add character.visible check here
                    let cx, cz, rotationY = 0; // Default rotation
                    if (f.type === 'move_to_ball') {
                        // Character moving towards a ball
                        const [sx, sy] = f.start.split(',').map(Number);
                        const [ex, ey] = f.end.split(',').map(Number);
                        cx = sx + 0.5 + f.alpha * (ex - sx);
                        cz = sy + 0.5 + f.alpha * (ey - sy);
                        // Determine rotation based on direction of movement
                        rotationY = f.direction === 'left' ? Math.PI : f.direction === 'right' ? 0 : f.direction === 'up' ? Math.PI / 2 : f.direction === 'down' ? -Math.PI / 2 : 0;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(cx, 0, cz);
                    } else if (['move_ball', 'push', 'roll', 'roll_ball'].includes(f.type)) {
                        // Character pushing/rolling a ball (character stays near the ball)
                        const [bx, by] = f.start.split(',').map(Number); // Ball's start
                        const [ex, ey] = f.end.split(',').map(Number); // Ball's end
                        cx = bx + 0.5 + f.alpha * (ex - bx); // Character moves with the ball
                        cz = by + 0.5 + f.alpha * (ey - by);
                        rotationY = f.direction === 'left' ? Math.PI : f.direction === 'right' ? 0 : f.direction === 'up' ? Math.PI / 2 : f.direction === 'down' ? -Math.PI / 2 : 0;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(balls[f.ball].position.x, balls[f.ball].position.y, balls[f.ball].position.z);
                    } else if (f.type === 'move') {
                        // Simple character movement
                        const [sx, sy] = f.start.split(',').map(Number);
                        const [ex, ey] = f.end.split(',').map(Number);
                        cx = sx + 0.5 + f.alpha * (ex - sx);
                        cz = sy + 0.5 + f.alpha * (ey - sy);
                        rotationY = f.direction === 'left' ? Math.PI : f.direction === 'right' ? 0 : f.direction === 'up' ? Math.PI / 2 : f.direction === 'down' ? -Math.PI / 2 : 0;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(cx, 0, cz);
                    } else {
                        // Static character position
                        const [x, y] = f.character.split(',').map(Number);
                        cx = x + 0.5;
                        cz = y + 0.5;
                        spotlight.position.set(cx, 2, cz);
                        spotlight.target.position.set(cx, 0, cz);
                    }
                    character.position.set(cx, 0, cz);
                    character.rotation.y = rotationY;
                    console.log(`[updateFrame] Character position set to (${cx.toFixed(2)}, 0, ${cz.toFixed(2)}) for frame ${Math.floor(currentFrame)}. Frame type: ${f.type}.`);
                }
            } catch (err) {
                console.error('Error updating frame:', err);
                showPopup('errorPopup', 'errorMessage', `Error updating frame: ${err.message}`);
            }
        }

        /**
         * Resets the entire scene to its initial state, clearing all dynamic objects and data.
         * The static environment (ground, grid, walls, trees, forbidden icons) remains.
         * @param {boolean} clearFiles - If true, also clears the selected problem and plan files.
         */
        function resetScene(clearFiles = true) {
            try {
                console.log('Resetting scene');
                // Reset plan data to default empty state, but keep the default problem data for static elements
                planData = {
                    problem: { ...defaultProblemData }, // Use a copy of defaultProblemData
                    frames: [],
                    isNumeric: false
                };
                currentFrame = 0;
                isPlaying = false;
                currentTime = 0;
                startTime = null;

                // Clear file inputs if requested
                if (clearFiles) {
                    problemFile = null;
                    planFile = null;
                    document.getElementById('problemFile').value = '';
                    document.getElementById('planFile').value = '';
                }

                // Reset UI elements
                playIcon.style.display = 'block'; // Show play icon
                pauseIcon.style.display = 'none'; // Hide pause icon
                playPauseText.textContent = 'Play'; // Set text to Play
                document.getElementById('step').value = 0;
                document.getElementById('step').max = 0;
                document.getElementById('step').disabled = true;
                ['playPause', 'stepForward', 'stepBackward', 'reset'].forEach(id => document.getElementById(id).disabled = true);

                // Clear only dynamic scene objects
                clearDynamicSceneObjects();
                // Re-initialize static environment to ensure grid colors are reset to their initial state (snow/forbidden)
                // This also re-adds forbidden icons if they were somehow removed.
                initStaticEnvironment(defaultProblemData);
                renderer.render(scene, camera); // Render the reset scene
            } catch (err) {
                console.error('Error resetting scene:', err);
                showPopup('errorPopup', 'errorMessage', `Error resetting scene: ${err.message}`);
            }
        }

        /**
         * Generates and returns a string with plan metrics.
         * @returns {string} - HTML formatted string of metrics.
         */
        function getMetrics() {
            const totalSteps = Math.floor(planData.frames.length / SUBSTEPS);
            const planDuration = currentTime.toFixed(2);
            // Count balls at goal in the final frame
            const ballsAtGoal = planData.frames.length > 0 ? Object.values(planData.frames[planData.frames.length - 1].balls).filter(pos => pos === GOAL_POS).length : 0;
            return `
                <strong>Plan Metrics:</strong><br>
                Total Steps: ${totalSteps}<br>
                Plan Duration: ${planDuration} seconds<br>
                Balls at Goal: ${ballsAtGoal}
            `;
        }

        /**
         * The main animation loop for Three.js.
         */
        function animate() {
            requestAnimationFrame(animate); // Request next frame
            const delta = clock.getDelta(); // Time elapsed since last frame
            controls.update(); // Update orbit controls

            // Update animation if playing and frames are available
            if (isPlaying && planData.frames.length > 0 && currentFrame < planData.frames.length - 1) {
                updateFrame(planData.frames[Math.floor(currentFrame)]); // Update scene based on current frame
                currentFrame += speed; // Advance frame based on speed
                document.getElementById('step').value = Math.floor(currentFrame / SUBSTEPS); // Update step slider
                currentTime = startTime ? (performance.now() - startTime) / 1000 : 0; // Update elapsed time
                if (currentFrame >= planData.frames.length - 1) {
                    isPlaying = false; // Stop playback at end of plan
                    playIcon.style.display = 'block'; // Show play icon
                    pauseIcon.style.display = 'none'; // Hide pause icon
                    playPauseText.textContent = 'Play'; // Set text to Play
                }
            }

            // Animate snow particles
            snowParticles.forEach((mesh, i) => {
                const velocity = snowParticleVelocities[i];
                mesh.position.x += velocity.x * delta;
                mesh.position.y += velocity.y * delta * snowSpeed; // Apply snowSpeed multiplier
                mesh.position.z += velocity.z * delta;
                // Remove snow particle if it falls below the ground
                if (mesh.position.y < 0) {
                    scene.remove(mesh);
                    snowParticles.splice(i, 1);
                    snowParticleVelocities.splice(i, 1);
                }
            });

            // Update character animation mixer if playing and character is moving
            if (mixer && isPlaying && planData.frames[Math.floor(currentFrame)] && ['move', 'move_to_ball', 'move_ball', 'push', 'roll', 'roll_ball'].includes(planData.frames[Math.floor(currentFrame)].type)) {
                mixer.update(delta);
            }

            renderer.render(scene, camera); // Render the scene
        }

        // --- Control Panel Drag and Resize Functionality ---
        const controlPanel = document.getElementById('controlPanel');
        let isDragging = false, currentX, currentY, isResizing = false, startX, startY, startWidth, startHeight;

        controlPanel.addEventListener('mousedown', e => {
            if (e.target.id === 'minimizeBtn') return; // Don't drag if minimize button clicked
            if (e.target.id === 'resizeHandle') {
                // Start resizing
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(document.defaultView.getComputedStyle(controlPanel).width, 10);
                startHeight = parseInt(document.defaultView.getComputedStyle(controlPanel).height, 10);
                controlPanel.style.cursor = 'se-resize';
            } else {
                // Start dragging
                isDragging = true;
                currentX = e.clientX - parseFloat(controlPanel.style.left || 0);
                currentY = e.clientY - parseFloat(controlPanel.style.top || 0);
                controlPanel.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', e => {
            if (isDragging) {
                let newLeft = e.clientX - currentX;
                let newTop = e.clientY - currentY;
                // Constrain panel within boundaries
                newLeft = Math.max(0, Math.min(newLeft, window.innerWidth * 0.35 - controlPanel.offsetWidth));
                newTop = Math.max(40, Math.min(newTop, window.innerHeight * 0.5 - controlPanel.offsetHeight));
                controlPanel.style.left = `${newLeft}px`;
                controlPanel.style.top = `${newTop}px`;
                controlPanel.style.transform = 'none'; // Remove any transform that might interfere
            } else if (isResizing) {
                const width = startWidth + (e.clientX - startX);
                const height = startHeight + (e.clientY - startY);
                // Constrain panel size within min/max
                controlPanel.style.width = `${Math.max(200, Math.min(400, width))}px`;
                controlPanel.style.height = `${Math.max(150, Math.min(600, height))}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            isResizing = false;
            controlPanel.style.cursor = 'move'; // Reset cursor
        });

        // --- UI Event Listeners ---

        // Minimize/Maximize control panel
        document.getElementById('minimizeBtn').addEventListener('click', () => {
            controlPanel.classList.toggle('minimized');
            if (controlPanel.classList.contains('minimized')) {
                document.getElementById('minimizeBtn').textContent = '+';
                // Hide all internal elements when minimized
                document.getElementById('problemFile').style.display = 'none';
                document.getElementById('planFile').style.display = 'none';
                document.querySelectorAll('#controlPanel button, #controlPanel label, #controlPanel input[type="range"]').forEach(el => el.style.display = 'none');
                document.getElementById('resizeHandle').style.display = 'none';
            } else {
                document.getElementById('minimizeBtn').textContent = '-';
                // Show all internal elements when maximized
                document.getElementById('problemFile').style.display = 'block';
                document.getElementById('planFile').style.display = 'block';
                document.querySelectorAll('#controlPanel button, #controlPanel label, #controlPanel input[type="range"]').forEach(el => el.style.display = 'block');
                document.getElementById('resizeHandle').style.display = 'block';
            }
        });

        // Toggle menu dropdown
        document.getElementById('menuBtn').addEventListener('click', () => {
            const menu = document.getElementById('menuDropdown');
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        });

        // Menu item click handlers
        document.getElementById('helpBtn').addEventListener('click', () => {
            showPopup('helpPopup', 'helpMessage', document.getElementById('helpMessage').innerHTML);
            document.getElementById('menuDropdown').style.display = 'none';
        });
        document.getElementById('metricsBtn').addEventListener('click', () => {
            showPopup('metricsPopup', 'metricsMessage', getMetrics());
            document.getElementById('menuDropdown').style.display = 'none';
        });
        document.getElementById('aboutBtn').addEventListener('click', () => {
            showPopup('aboutPopup', 'aboutMessage', document.getElementById('aboutMessage').innerHTML);
            document.getElementById('menuDropdown').style.display = 'none';
        });

        // Pop-up close button handlers
        document.getElementById('errorClose').addEventListener('click', () => hidePopup('errorPopup'));
        document.getElementById('helpClose').addEventListener('click', () => hidePopup('helpPopup'));
        document.getElementById('metricsClose').addEventListener('click', () => hidePopup('metricsPopup'));
        document.getElementById('aboutClose').addEventListener('click', () => hidePopup('aboutPopup'));

        // File input change listeners
        document.getElementById('problemFile').addEventListener('change', selectFiles);
        document.getElementById('planFile').addEventListener('change', selectFiles);

        // Play/Pause button
        document.getElementById('playPause').addEventListener('click', () => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to start the animation.');
                return;
            }
            isPlaying = !isPlaying;
            if (isPlaying) {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
                playPauseText.textContent = 'Pause';
                if (!startTime) startTime = performance.now(); // Start timer if playing for the first time
            } else {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                playPauseText.textContent = 'Play';
            }
        });

        // Step Forward button
        document.getElementById('stepForward').addEventListener('click', () => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to step through the plan.');
                return;
            }
            if (!isPlaying && currentFrame < planData.frames.length - SUBSTEPS) {
                currentFrame = Math.min(currentFrame + SUBSTEPS, planData.frames.length - 1);
                document.getElementById('step').value = Math.floor(currentFrame / SUBSTEPS);
                updateFrame(planData.frames[Math.floor(currentFrame)]);
            }
        });

        // Step Backward button
        document.getElementById('stepBackward').addEventListener('click', () => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to step through the plan.');
                return;
            }
            if (!isPlaying && currentFrame >= SUBSTEPS) {
                currentFrame -= SUBSTEPS;
                document.getElementById('step').value = Math.floor(currentFrame / SUBSTEPS);
                updateFrame(planData.frames[Math.floor(currentFrame)]);
            }
        });

        // Reset button
        document.getElementById('reset').addEventListener('click', () => resetScene(true));

        // Speed slider
        document.getElementById('speed').addEventListener('input', e => speed = Number(e.target.value));

        // Snow Speed slider
        document.getElementById('snowSpeed').addEventListener('input', e => snowSpeed = Number(e.target.value));

        // Step slider
        document.getElementById('step').addEventListener('input', e => {
            if (planData.frames.length === 0) {
                showPopup('errorPopup', 'errorMessage', 'Please select both a problem file (.pddl) and a plan file (.txt or .plan) to use the step slider.');
                return;
            }
            currentFrame = Number(e.target.value) * SUBSTEPS;
            isPlaying = false; // Pause animation when manually stepping
            playIcon.style.display = 'block'; // Show play icon
            pauseIcon.style.display = 'none'; // Hide pause icon
            playPauseText.textContent = 'Play'; // Set text to Play
            updateFrame(planData.frames[Math.floor(currentFrame)]);
        });

        // Handle window resize for responsive canvas
        window.addEventListener('resize', () => {
            camera.aspect = 0.65 * window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.65, window.innerHeight - 70);
            // Re-position control panel to avoid being off-screen if window shrinks
            controlPanel.style.left = '10px';
            controlPanel.style.top = '50px';
        });

        // Initialize the application when the script loads
        window.onload = async function() {
            await initCoreThreeJs(); // Initialize core Three.js components (renderer, camera, lights, etc.)
            await initStaticEnvironment(defaultProblemData); // Setup the static board elements
            renderer.render(scene, camera); // Render the initial scene with the board
        };
    </script>
   <script type="module" src="../static/js/visualizer.js"></script>
</body>
</html>
